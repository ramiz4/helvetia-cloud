[
  {
    "title": "[CRITICAL] Hardcoded Cryptographic Salt in Encryption",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "The encryption module uses a hardcoded salt value `'salt'` for key derivation, which completely defeats the purpose of encryption and makes GitHub access tokens vulnerable to decryption.\n\n**Location:**\n`apps/api/src/utils/crypto.ts:8`\n\n**Current Code:**\n\n```typescript\nconst ENCRYPTION_KEY = crypto.scryptSync(KEY, 'salt', 32);\n```\n\n**Security Impact:**\n\n- GitHub access tokens are vulnerable to rainbow table attacks\n- If database is compromised, tokens can be easily decrypted\n- Violates cryptographic best practices\n\n**Recommended Fix:**\n\n```typescript\nconst SALT = process.env.ENCRYPTION_SALT || crypto.randomBytes(32).toString('hex');\nconst ENCRYPTION_KEY = crypto.scryptSync(KEY, SALT, 32);\n```\n\n**Better Solution:**\nUse a proper key management service (AWS KMS, HashiCorp Vault) or at minimum, store a secure random salt in environment variables.\n\n**Acceptance Criteria:**\n\n- [ ] Remove hardcoded salt\n- [ ] Generate unique salt per installation\n- [ ] Store salt securely in environment variables\n- [ ] Update .env.example with ENCRYPTION_SALT\n- [ ] Document migration path for existing encrypted data\n- [ ] Add tests for encryption/decryption",
    "number": 56,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/56",
    "synced": true
  },
  {
    "title": "[CRITICAL] Missing Rate Limiting Implementation",
    "labels": [
      "P0",
      "security",
      "critical",
      "enhancement"
    ],
    "body": "Despite having rate limiting configuration in environment variables, no rate limiting is actually implemented. Critical endpoints are vulnerable to brute-force and DoS attacks.\n\n**Vulnerable Endpoints:**\n\n- `/auth/github` - OAuth callback (brute force risk)\n- `/services/:id/deploy` - Resource-intensive operations (DoS risk)\n- `/webhooks/github` - External webhook (abuse risk)\n- All authenticated endpoints\n\n**Impact:**\n\n- Brute-force attacks on authentication\n- DoS through excessive deployment requests\n- Webhook spam overwhelming the system\n- Resource exhaustion\n\n**Recommended Implementation:**\n\n```typescript\nimport rateLimit from '@fastify/rate-limit';\n\n// Global rate limiting\nfastify.register(rateLimit, {\n  max: parseInt(process.env.RATE_LIMIT_MAX || '100'),\n  timeWindow: process.env.RATE_LIMIT_WINDOW || '1 minute',\n  redis: redisConnection,\n  keyGenerator: (request) => request.ip,\n});\n\n// Stricter limit for auth routes\nfastify.register(\n  rateLimit,\n  {\n    max: parseInt(process.env.AUTH_RATE_LIMIT_MAX || '10'),\n    timeWindow: process.env.AUTH_RATE_LIMIT_WINDOW || '1 minute',\n    redis: redisConnection,\n  },\n  { prefix: '/auth' },\n);\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install @fastify/rate-limit dependency\n- [ ] Implement global rate limiting\n- [ ] Implement stricter limits for authentication endpoints\n- [ ] Implement limits for deployment endpoints\n- [ ] Implement limits for WebSocket/SSE connections\n- [ ] Exclude /health endpoint from rate limiting\n- [ ] Add rate limit headers in responses\n- [ ] Add tests for rate limiting\n- [ ] Document rate limits in API docs",
    "number": 58,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/58",
    "synced": true
  },
  {
    "title": "[CRITICAL] GitHub Webhook Authentication Missing",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "GitHub webhooks endpoint (`/webhooks/github`) processes requests without verifying the signature. Anyone can trigger deployments by sending POST requests to this endpoint.\n\n**Location:**\n`apps/api/src/server.ts:979-1152`\n\n**Current Code:**\n\n```typescript\nfastify.post('/webhooks/github', async (request) => {\n  const payload = request.body as any;\n  // No signature verification!\n```\n\n**Security Impact:**\n\n- Unauthorized deployments can be triggered\n- Malicious actors can cause resource exhaustion\n- Preview environments can be created/destroyed without authorization\n- Potential for code injection through malicious payloads\n\n**Recommended Fix:**\n\n```typescript\nimport crypto from 'crypto';\n\nfunction verifyGitHubSignature(payload: string, signature: string, secret: string): boolean {\n  const hmac = crypto.createHmac('sha256', secret);\n  const digest = 'sha256=' + hmac.update(payload).digest('hex');\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));\n}\n\nfastify.post('/webhooks/github', async (request, reply) => {\n  const signature = request.headers['x-hub-signature-256'] as string;\n\n  if (!signature) {\n    return reply.status(401).send({ error: 'Missing signature' });\n  }\n\n  const rawBody = JSON.stringify(request.body);\n\n  if (!verifyGitHubSignature(rawBody, signature, process.env.GITHUB_WEBHOOK_SECRET!)) {\n    return reply.status(401).send({ error: 'Invalid signature' });\n  }\n\n  // ... process webhook\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add GITHUB_WEBHOOK_SECRET to environment variables\n- [ ] Implement signature verification function\n- [ ] Add signature verification to webhook endpoint\n- [ ] Return 401 for missing or invalid signatures\n- [ ] Log suspicious requests\n- [ ] Add tests for signature verification\n- [ ] Update documentation with webhook setup instructions\n- [ ] Update .env.example",
    "number": 59,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/59",
    "synced": true
  },
  {
    "title": "[CRITICAL] Insecure CORS Configuration Allows Origin Reflection",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "SSE endpoints reflect the request origin back in `Access-Control-Allow-Origin` header with credentials enabled, effectively bypassing CORS protection.\n\n**Locations:**\n\n- `apps/api/src/server.ts:654-661` (metrics stream)\n- `apps/api/src/server.ts:1199-1206` (logs stream)\n\n**Vulnerable Code:**\n\n```typescript\n'Access-Control-Allow-Origin': request.headers.origin || '*',\n'Access-Control-Allow-Credentials': 'true',\n```\n\n**Security Impact:**\n\n- Cross-origin attacks possible\n- Session hijacking risk\n- CSRF vulnerabilities\n- Sensitive data exposure to malicious origins\n\n**Recommended Fix:**\n\n```typescript\nconst allowedOrigins = (\n  process.env.ALLOWED_ORIGINS ||\n  process.env.APP_BASE_URL ||\n  'http://localhost:3000'\n)\n  .split(',')\n  .map((o) => o.trim());\n\nfastify.register(cors, {\n  origin: (origin, cb) => {\n    if (!origin || allowedOrigins.includes(origin)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Not allowed by CORS'), false);\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],\n});\n\n// For SSE endpoints\nreply.raw.writeHead(200, {\n  'Content-Type': 'text/event-stream',\n  'Cache-Control': 'no-cache',\n  Connection: 'keep-alive',\n  'X-Accel-Buffering': 'no',\n  'Access-Control-Allow-Origin': allowedOrigins.includes(request.headers.origin || '')\n    ? request.headers.origin\n    : allowedOrigins[0],\n  'Access-Control-Allow-Credentials': 'true',\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add ALLOWED_ORIGINS environment variable\n- [ ] Implement strict origin validation\n- [ ] Fix CORS configuration in server setup\n- [ ] Fix CORS headers in SSE endpoints\n- [ ] Remove wildcard origin fallback\n- [ ] Add tests for CORS validation\n- [ ] Document CORS configuration\n- [ ] Update .env.example",
    "number": 60,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/60",
    "synced": true
  },
  {
    "title": "[CRITICAL] Host Filesystem Exposure via Docker Volume Mount",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "Worker mounts the entire `/Users` directory into builder containers, exposing all user data on macOS. This is extremely dangerous.\n\n**Location:**\n`apps/worker/src/worker.ts:104, 216`\n\n**Vulnerable Code:**\n\n```typescript\nBinds: ['/var/run/docker.sock:/var/run/docker.sock', '/Users:/Users'],\n```\n\n**Security Impact:**\n\n- Container can access all user data on macOS\n- Host filesystem can be modified by container\n- Privilege escalation possible\n- Violates principle of least privilege\n- Data breach risk\n\n**Recommended Fix:**\n\n```typescript\n// Only mount specific workspace directory, read-only\nconst workDir = process.env.WORKSPACE_DIR || '/tmp/helvetia-workspaces';\n\n// Ensure directory exists\nawait fs.promises.mkdir(workDir, { recursive: true });\n\nBinds: [\n  '/var/run/docker.sock:/var/run/docker.sock',\n  `${workDir}:/workspaces:ro`, // Read-only mount\n],\n```\n\n**Additional Security:**\n\n- Use temporary directories that are cleaned up\n- Never mount root directories\n- Use SELinux/AppArmor labels\n- Consider using Docker volumes instead of bind mounts\n\n**Acceptance Criteria:**\n\n- [ ] Remove /Users mount completely\n- [ ] Create dedicated workspace directory\n- [ ] Mount workspace as read-only\n- [ ] Add WORKSPACE_DIR environment variable\n- [ ] Implement workspace cleanup\n- [ ] Add documentation warning about production usage\n- [ ] Add tests to verify mount configuration\n- [ ] Update .env.example",
    "number": 61,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/61",
    "synced": true
  },
  {
    "title": "[HIGH] SQL Injection Risk with Prisma String Operations",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "Using `contains` with unsanitized user input in Prisma queries could be vulnerable to SQL injection or at minimum, unexpected behavior.\n\n**Location:**\nMultiple locations in `apps/api/src/server.ts`\n\n**Example:**\n\n```typescript\nwhere: {\n  repoUrl: {\n    contains: repoUrl;\n  }\n}\n```\n\n**Recommended Fix:**\n\n```typescript\nconst sanitizedRepoUrl = repoUrl.trim().replace(/\\.git$/, '');\nwhere: {\n  OR: [{ repoUrl: sanitizedRepoUrl }, { repoUrl: `${sanitizedRepoUrl}.git` }];\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Audit all Prisma queries using user input\n- [ ] Sanitize repo URLs before querying\n- [ ] Use exact matches where possible\n- [ ] Add input validation tests\n- [ ] Document safe query patterns",
    "number": 66,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/66",
    "synced": true
  },
  {
    "title": "[HIGH] Missing Comprehensive Input Validation",
    "labels": [
      "P1",
      "security",
      "enhancement"
    ],
    "body": "Service creation and update endpoints lack comprehensive input validation, allowing potentially malicious or malformed data.\n\n**Location:**\n`apps/api/src/server.ts:500-597`\n\n**Missing Validations:**\n\n- Service name format (could contain special characters)\n- URL validation for repoUrl\n- Command injection prevention for buildCommand/startCommand\n- Size limits for envVars\n- Branch name validation\n\n**Recommended Implementation:**\nUse Zod for schema validation:\n\n```typescript\nimport { z } from 'zod';\n\nconst ServiceCreateSchema = z.object({\n  name: z\n    .string()\n    .min(3)\n    .max(63)\n    .regex(/^[a-z0-9-]+$/),\n  repoUrl: z.url().optional(),\n  branch: z\n    .string()\n    .min(1)\n    .max(255)\n    .regex(/^[a-zA-Z0-9-_./]+$/),\n  buildCommand: z.string().max(1000).optional(),\n  startCommand: z.string().max(1000).optional(),\n  port: z.number().int().min(1).max(65535),\n  envVars: z.record(z.string()).optional(),\n  customDomain: z.string().max(255).optional(),\n  type: z.enum(['DOCKER', 'STATIC', 'POSTGRES', 'REDIS', 'MYSQL', 'COMPOSE']),\n  staticOutputDir: z.string().max(255).optional(),\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install zod dependency\n- [ ] Create validation schemas for all endpoints\n- [ ] Implement request validation middleware\n- [ ] Return detailed validation errors\n- [ ] Add tests for validation\n- [ ] Document API request/response schemas",
    "number": 67,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/67",
    "synced": true
  },
  {
    "title": "[HIGH] SSE Connection Token Expiration Not Handled",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "Long-lived SSE connections don't re-validate JWT tokens, potentially allowing access after token expiration.\n\n**Locations:**\n\n- `apps/api/src/server.ts:650-705` (metrics)\n- `apps/api/src/server.ts:1184-1230` (logs)\n\n**Recommended Fix:**\nImplement periodic token validation in SSE streams.\n\n**Acceptance Criteria:**\n\n- [ ] Add periodic token validation (every 5 minutes)\n- [ ] Close connection on token expiration\n- [ ] Implement graceful reconnection on client side\n- [ ] Add tests for token expiration handling\n- [ ] Document SSE connection lifecycle",
    "number": 68,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/68",
    "synced": true
  },
  {
    "title": "[HIGH] Incomplete Error Handling in Worker Deployment",
    "labels": [
      "P1",
      "bug",
      "reliability"
    ],
    "body": "Worker's catch block doesn't handle partial failures properly. Resources may not be cleaned up correctly on deployment failure.\n\n**Location:**\n`apps/worker/src/worker.ts:435-445`\n\n**Issues:**\n\n- Builder container might not be cleaned up\n- Old containers might not be restarted on rollback\n- No rollback mechanism for failed deployments\n\n**Acceptance Criteria:**\n\n- [ ] Implement comprehensive cleanup in catch block\n- [ ] Add rollback to previous container on failure\n- [ ] Ensure builder container always cleaned up\n- [ ] Log detailed error information\n- [ ] Add tests for failure scenarios\n- [ ] Update deployment status correctly on all paths",
    "number": 70,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/70",
    "synced": true
  },
  {
    "title": "[HIGH] Race Condition in Service Status Updates",
    "labels": [
      "P1",
      "bug",
      "concurrency"
    ],
    "body": "Service status is updated from multiple places without synchronization, leading to race conditions and stale data.\n\n**Locations:**\n\n- API sets status to DEPLOYING when queuing\n- Worker sets status after deployment\n- Docker status checked asynchronously\n\n**Recommended Solution:**\nImplement Redis-based distributed locks using Redlock.\n\n**Acceptance Criteria:**\n\n- [ ] Install redlock dependency\n- [ ] Implement distributed locking for status updates\n- [ ] Create status reconciliation service\n- [ ] Add tests for concurrent updates\n- [ ] Document status lifecycle",
    "number": 71,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/71",
    "synced": true
  },
  {
    "title": "[HIGH] Docker Socket Security Risk",
    "labels": [
      "P1",
      "security",
      "architecture"
    ],
    "body": "Direct Docker socket access in both API and Worker provides root-level access to host system.\n\n**Impact:**\n\n- Container escape vulnerabilities\n- Host system compromise potential\n- Privilege escalation risks\n\n**Recommended Solutions:**\n\n1. Run Docker daemon in rootless mode\n2. Implement Docker socket proxy with ACLs\n3. Consider migrating to Kubernetes\n\n**Acceptance Criteria:**\n\n- [ ] Document security implications\n- [ ] Implement Docker socket proxy\n- [ ] Add SELinux/AppArmor policies\n- [ ] Create security hardening guide\n- [ ] Consider Kubernetes migration path",
    "number": 72,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/72",
    "synced": true
  },
  {
    "title": "[HIGH] Memory Leak Risk in SSE Connections",
    "labels": [
      "P1",
      "bug",
      "performance"
    ],
    "body": "SSE connection intervals may not be properly cleaned up on errors, leading to memory leaks.\n\n**Location:**\n`apps/api/src/server.ts:650-705`\n\n**Recommended Fix:**\nAdd comprehensive error handling and cleanup.\n\n**Acceptance Criteria:**\n\n- [ ] Add error handling in interval callbacks\n- [ ] Ensure cleanup on all error paths\n- [ ] Add connection state tracking\n- [ ] Implement connection timeout\n- [ ] Add tests for error scenarios\n- [ ] Monitor memory usage",
    "number": 73,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/73",
    "synced": true
  },
  {
    "title": "[HIGH] Unrestricted Service Deletion Risk",
    "labels": [
      "P1",
      "bug",
      "data-loss"
    ],
    "body": "Service deletion is permanent and irreversible without safety mechanisms.\n\n**Recommended Implementation:**\nImplement soft deletion with retention period.\n\n**Acceptance Criteria:**\n\n- [ ] Add deletedAt field to Service model\n- [ ] Implement soft deletion\n- [ ] Add delete protection flag\n- [ ] Schedule cleanup after retention period\n- [ ] Add recovery mechanism\n- [ ] Require re-authentication for deletion\n- [ ] Add tests for deletion flow",
    "number": 74,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/74",
    "synced": true
  },
  {
    "title": "[MEDIUM] Missing Dockerfile Generation Validation",
    "labels": [
      "P2",
      "enhancement",
      "reliability"
    ],
    "body": "Generated Dockerfiles aren't validated before build, leading to hard-to-debug failures.\n\n**Location:**\n`apps/worker/src/worker.ts:225-310`\n\n**Acceptance Criteria:**\n\n- [ ] Add Dockerfile syntax validation\n- [ ] Implement dry-run before build\n- [ ] Validate environment variable format\n- [ ] Add better error messages\n- [ ] Add tests for various scenarios",
    "number": 75,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/75",
    "synced": true
  },
  {
    "title": "[MEDIUM] Hardcoded Magic Numbers Throughout Codebase",
    "labels": [
      "P2",
      "refactoring",
      "maintainability"
    ],
    "body": "Magic numbers scattered throughout code reduce maintainability.\n\n**Examples:**\n\n- `512 * 1024 * 1024` (Memory limit)\n- `1000000000` (CPU limit)\n- `5000` (Metrics interval)\n\n**Acceptance Criteria:**\n\n- [ ] Create constants configuration file\n- [ ] Extract all magic numbers\n- [ ] Make limits configurable via env vars\n- [ ] Update documentation\n- [ ] Add tests with different configurations",
    "number": 76,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/76",
    "synced": true
  },
  {
    "title": "[MEDIUM] Missing Request/Response Logging",
    "labels": [
      "P2",
      "observability",
      "enhancement"
    ],
    "body": "No structured logging for requests and responses, making debugging difficult.\n\n**Acceptance Criteria:**\n\n- [ ] Implement request logging hook\n- [ ] Implement response logging hook\n- [ ] Add structured logging with context\n- [ ] Configure log levels per environment\n- [ ] Add request ID correlation\n- [ ] Document logging format",
    "number": 77,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/77",
    "synced": true
  },
  {
    "title": "[MEDIUM] No Health Check Endpoint for Worker",
    "labels": [
      "P2",
      "observability",
      "enhancement"
    ],
    "body": "Worker service lacks health check endpoint for monitoring.\n\n**Acceptance Criteria:**\n\n- [ ] Add HTTP health endpoint\n- [ ] Include queue stats\n- [ ] Include Redis connection status\n- [ ] Include uptime information\n- [ ] Document health check format\n- [ ] Add monitoring setup guide",
    "number": 78,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/78",
    "synced": true
  },
  {
    "title": "[MEDIUM] Incomplete Test Coverage",
    "labels": [
      "P2",
      "testing",
      "quality"
    ],
    "body": "Test suite exists but critical paths aren't fully covered.\n\n**Missing Tests:**\n\n- Integration tests for deployment flow\n- Webhook processing tests\n- SSE streaming tests\n- Worker deployment tests (currently failing)\n\n**Acceptance Criteria:**\n\n- [ ] Fix failing worker tests\n- [ ] Add integration tests\n- [ ] Achieve 80% code coverage minimum\n- [ ] Add E2E tests for critical flows\n- [ ] Set up test containers for integration tests\n- [ ] Add coverage reporting to CI",
    "number": 79,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/79",
    "synced": true
  },
  {
    "title": "[MEDIUM] Environment Variable Management Needs Improvement",
    "labels": [
      "P2",
      "enhancement",
      "configuration"
    ],
    "body": "No validation for required environment variables, leading to potential runtime errors.\n\n**Acceptance Criteria:**\n\n- [ ] Install zod for validation\n- [ ] Create environment schema\n- [ ] Validate on startup\n- [ ] Provide clear error messages\n- [ ] Add type safety for env vars\n- [ ] Update documentation",
    "number": 80,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/80",
    "synced": true
  },
  {
    "title": "[MEDIUM] No Database Migration Strategy",
    "labels": [
      "P2",
      "database",
      "deployment"
    ],
    "body": "Using `db:push` instead of migrations is dangerous for production.\n\n**Issues:**\n\n- No migration history\n- Can cause data loss\n- Can't rollback changes\n- No team collaboration on schema changes\n\n**Acceptance Criteria:**\n\n- [ ] Switch to Prisma Migrate\n- [ ] Create initial migration\n- [ ] Update deployment scripts\n- [ ] Document migration workflow\n- [ ] Add rollback procedures\n- [ ] Update CI/CD pipeline",
    "number": 81,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/81",
    "synced": true
  },
  {
    "title": "[MEDIUM] Frontend State Management Issues",
    "labels": [
      "P2",
      "frontend",
      "performance"
    ],
    "body": "Dashboard has performance issues and state management anti-patterns.\n\n**Issues:**\n\n- Services fetched on every re-render\n- No caching mechanism\n- Large component needs splitting\n- Optimistic updates without proper rollback\n\n**Acceptance Criteria:**\n\n- [ ] Install React Query or SWR\n- [ ] Implement data caching\n- [ ] Split large components\n- [ ] Add error boundaries\n- [ ] Implement proper loading states\n- [ ] Add tests for state management",
    "number": 82,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/82",
    "synced": true
  },
  {
    "title": "[MEDIUM] Docker Image Cleanup Missing",
    "labels": [
      "P2",
      "infrastructure",
      "resource-management"
    ],
    "body": "No cleanup for dangling, failed, or old Docker images, leading to disk space issues.\n\n**Acceptance Criteria:**\n\n- [ ] Implement periodic cleanup job\n- [ ] Remove dangling images\n- [ ] Remove old image versions\n- [ ] Add retention policy\n- [ ] Monitor disk usage\n- [ ] Add configuration options",
    "number": 83,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/83",
    "synced": true
  },
  {
    "title": "[MEDIUM] Missing Prometheus Metrics",
    "labels": [
      "P2",
      "observability",
      "monitoring"
    ],
    "body": "No metrics exported for system monitoring.\n\n**Needed Metrics:**\n\n- Request rates and latencies\n- Error rates\n- Deployment success/failure rates\n- Queue depths\n- Resource usage\n\n**Acceptance Criteria:**\n\n- [ ] Install prom-client\n- [ ] Add /metrics endpoint\n- [ ] Implement custom metrics\n- [ ] Add Grafana dashboard\n- [ ] Document metrics\n- [ ] Set up alerting",
    "number": 84,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/84",
    "synced": true
  },
  {
    "title": "[MEDIUM] Session Management Needs Refresh Tokens",
    "labels": [
      "P2",
      "security",
      "enhancement"
    ],
    "body": "JWT tokens have 7-day expiration with no refresh mechanism.\n\n**Acceptance Criteria:**\n\n- [ ] Implement refresh token flow\n- [ ] Use short-lived access tokens (15 min)\n- [ ] Implement token rotation\n- [ ] Add token revocation list in Redis\n- [ ] Update frontend to handle refresh\n- [ ] Add tests for token lifecycle",
    "number": 69,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/69",
    "synced": true
  },
  {
    "title": "[MEDIUM] No Request Size Limits",
    "labels": [
      "P2",
      "security",
      "performance"
    ],
    "body": "Missing request body size limits could allow DoS attacks.\n\n**Acceptance Criteria:**\n\n- [ ] Add body size limit to Fastify config\n- [ ] Configure appropriate limits (10MB default)\n- [ ] Add limits per endpoint type\n- [ ] Document size limits\n- [ ] Add tests for size validation\n- [ ] Return appropriate error messages",
    "number": 85,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/85",
    "synced": true
  },
  {
    "title": "[LOW] Excessive TypeScript `any` Usage",
    "labels": [
      "P3",
      "refactoring",
      "type-safety"
    ],
    "body": "Extensive use of `any` type reduces type safety benefits.\n\n**Acceptance Criteria:**\n\n- [ ] Add Fastify type augmentation\n- [ ] Create proper request/response types\n- [ ] Remove `as any` casts\n- [ ] Enable stricter TypeScript checks\n- [ ] Document type patterns",
    "number": 93,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/93",
    "synced": true
  },
  {
    "title": "[LOW] Inconsistent Error Messages",
    "labels": [
      "P3",
      "ux",
      "enhancement"
    ],
    "body": "Error messages aren't user-friendly or consistent.\n\n**Acceptance Criteria:**\n\n- [ ] Create error response standard\n- [ ] Add error codes\n- [ ] Make messages user-friendly\n- [ ] Add i18n support for errors\n- [ ] Document error codes\n- [ ] Update frontend error handling",
    "number": 87,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/87",
    "synced": true
  },
  {
    "title": "[LOW] Missing API Versioning",
    "labels": [
      "P3",
      "api",
      "architecture"
    ],
    "body": "No API versioning strategy makes future changes risky.\n\n**Acceptance Criteria:**\n\n- [ ] Add version prefix (/api/v1)\n- [ ] Document versioning strategy\n- [ ] Plan v2 transition path\n- [ ] Update frontend API calls\n- [ ] Add version negotiation",
    "number": 88,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/88",
    "synced": true
  },
  {
    "title": "[LOW] No Request ID Tracing",
    "labels": [
      "P3",
      "observability",
      "enhancement"
    ],
    "body": "Missing correlation IDs makes request tracing difficult.\n\n**Acceptance Criteria:**\n\n- [ ] Add request ID generation\n- [ ] Propagate IDs across services\n- [ ] Include in all log entries\n- [ ] Return in response headers\n- [ ] Document tracing setup",
    "number": 89,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/89",
    "synced": true
  },
  {
    "title": "[LOW] Lack of Feature Flags",
    "labels": [
      "P3",
      "deployment",
      "enhancement"
    ],
    "body": "No way to enable/disable features without deployment.\n\n**Acceptance Criteria:**\n\n- [ ] Choose feature flag service\n- [ ] Implement feature flag checks\n- [ ] Add admin UI for flags\n- [ ] Document feature flag usage\n- [ ] Add A/B testing capability",
    "number": 90,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/90",
    "synced": true
  },
  {
    "title": "[LOW] No Graceful Shutdown",
    "labels": [
      "P3",
      "reliability",
      "enhancement"
    ],
    "body": "Services don't handle SIGTERM/SIGINT gracefully.\n\n**Acceptance Criteria:**\n\n- [ ] Implement graceful shutdown\n- [ ] Wait for in-flight requests\n- [ ] Close connections properly\n- [ ] Update deployment docs\n- [ ] Add tests for shutdown",
    "number": 91,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/91",
    "synced": true
  },
  {
    "title": "[LOW] Dashboard Accessibility Issues",
    "labels": [
      "P3",
      "accessibility",
      "a11y",
      "frontend"
    ],
    "body": "Several accessibility improvements needed for WCAG compliance.\n\n**Issues:**\n\n- Missing ARIA labels\n- Insufficient color contrast\n- No keyboard navigation hints\n- Modal focus trap not complete\n\n**Acceptance Criteria:**\n\n- [ ] Run axe-core audit\n- [ ] Fix all critical a11y issues\n- [ ] Add ARIA labels\n- [ ] Improve color contrast\n- [ ] Implement proper focus management\n- [ ] Add keyboard navigation\n- [ ] Test with screen readers",
    "number": 92,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/92",
    "synced": true
  },
  {
    "title": "[HIGH] Implement Dependency Injection & Core Interfaces",
    "labels": [
      "P1",
      "refactoring",
      "architecture"
    ],
    "body": "Introduce dependency injection to decouple components and enable testability.\n\n**Current Issue:**\n- Direct instantiation of Docker, Redis, Prisma throughout codebase\n- Cannot mock dependencies for testing\n- Cannot swap implementations\n\n**Tasks:**\n\n- [ ] Set up DI framework (TSyringe or InversifyJS)\n- [ ] Define core interface contracts (IServiceRepository, IDeploymentRepository, IUserRepository, IContainerOrchestrator, IDeploymentQueue, ILogger, ICache)\n- [ ] Create base error hierarchy (AppError, ValidationError, NotFoundError)\n- [ ] Set up DI container configuration\n\n**Note:** This issue defines interface contracts only. Implementations are handled by other issues (#95 for repositories, #97 for container orchestrator).\n\n**Benefits:**\n- Better testability\n- Loose coupling\n- Easier to swap implementations",
    "number": 125,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/125"
  },
  {
    "title": "[HIGH] Extract Repository Pattern for Data Access",
    "labels": [
      "P1",
      "refactoring",
      "database"
    ],
    "body": "Implement repository pattern for data access using interfaces from #94.\n\n**Current Issue:**\n- Prisma queries scattered throughout route handlers\n- Business logic mixed with data access\n- Hard to test and maintain\n\n**Tasks:**\n\n- [ ] Implement Prisma-based repositories (ServiceRepository, DeploymentRepository, UserRepository) using interfaces from #94\n- [ ] Replace direct Prisma calls with repository methods\n- [ ] Add repository unit tests\n- [ ] Register repositories in DI container\n\n**Dependencies:** Requires #94 (interface definitions)\n\n**Benefits:**\n- Clean separation of data access\n- Easier to test business logic\n- Can swap database implementations",
    "number": 126,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/126"
  },
  {
    "title": "[HIGH] Create Service Layer for Business Logic",
    "labels": [
      "P1",
      "refactoring",
      "architecture"
    ],
    "body": "Extract business logic from route handlers into dedicated service classes.\n\n**Current Issue:**\n- Business logic embedded in route handlers\n- No reusability across endpoints\n- Difficult to test in isolation\n\n**Tasks:**\n\n- [ ] Create application services (ServiceManagementService, DeploymentOrchestrator, AuthenticationService)\n- [ ] Extract business logic from route handlers into services\n- [ ] Define DTOs and validation schemas\n- [ ] Add comprehensive service tests\n- [ ] Register services in DI container\n\n**Note:** Complete this before #98 (route refactoring). #98 will then handle the remaining route/controller structure.\n\n**Dependencies:** Works best after #94 (DI setup) and #95 (repositories)\n\n**Benefits:**\n- Testable business logic\n- Reusable across different interfaces\n- Clear separation of concerns",
    "number": 127,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/127"
  },
  {
    "title": "[MEDIUM] Abstract Container Orchestration Logic",
    "labels": [
      "P2",
      "refactoring",
      "infrastructure"
    ],
    "body": "Implement container orchestration abstraction using interface from #94.\n\n**Current Issue:**\n- Container management duplicated in API and Worker\n- Direct Docker API calls throughout\n- Cannot easily test container logic\n\n**Tasks:**\n\n- [ ] Implement DockerContainerOrchestrator using IContainerOrchestrator interface from #94\n- [ ] Extract container utilities (VolumeManager, NetworkManager, HealthChecker)\n- [ ] Replace direct Docker calls with orchestrator\n- [ ] Add integration tests\n- [ ] Register orchestrator in DI container\n\n**Note:** Package migration to shared location is handled by #101.\n\n**Dependencies:** Requires #94 (interface definition). Can work in parallel with #95, #96, #98.\n\n**Benefits:**\n- DRY - single container implementation\n- Can work in parallel with route refactoring\n- Easier to test",
    "number": 128,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/128"
  },
  {
    "title": "[MEDIUM] Refactor API Routes into Controllers",
    "labels": [
      "P2",
      "refactoring",
      "api"
    ],
    "body": "Split monolithic server.ts into focused controllers and route files after business logic extraction.\n\n**Current Issue:**\n- Single file handles all routes, auth, remaining logic\n- Hard to navigate and maintain\n- High risk of merge conflicts\n\n**Tasks:**\n\n- [ ] Create thin controller classes (ServiceController, DeploymentController, AuthController, WebhookController) that call services from #96\n- [ ] Extract route definitions to separate files\n- [ ] Implement middleware (auth, validation, error handling)\n- [ ] Refactor SSE/WebSocket handlers\n\n**Dependencies:** Should be done after #96 (service layer) to avoid refactoring business logic twice.\n\n**Benefits:**\n- Smaller, focused files\n- Reduced merge conflicts\n- Easier to navigate codebase",
    "number": 129,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/129"
  },
  {
    "title": "[MEDIUM] Implement Strategy Pattern for Deployment Types",
    "labels": [
      "P2",
      "refactoring",
      "worker"
    ],
    "body": "Use Strategy Pattern to handle different service deployment types.\n\n**Current Issue:**\n- Hardcoded if/else checks for service types\n- Adding new types requires modifying existing code\n- Violates Open/Closed Principle\n\n**Tasks:**\n\n- [ ] Create IDeploymentStrategy interface\n- [ ] Implement strategies (DockerDeploymentStrategy, StaticDeploymentStrategy, DatabaseDeploymentStrategy, ComposeDeploymentStrategy)\n- [ ] Update worker to use strategy pattern\n- [ ] Extract builders (DockerfileBuilder, ComposeFileBuilder)\n- [ ] Add strategy tests\n\n**Note:** Can work independently from API refactoring (#96, #98) since it focuses on worker.\n\n**Benefits:**\n- Easy to add new service types\n- Better code organization\n- Can work independently from API refactoring",
    "number": 130,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/130"
  },
  {
    "title": "[MEDIUM] Improve TypeScript Type Safety",
    "labels": [
      "P2",
      "refactoring",
      "type-safety",
      "duplicate"
    ],
    "body": "**Note:** This issue duplicates #93. Please use #93 for all TypeScript type safety improvements.\n\n**Closing Reason:** Issue #93 already tracks the same work:\n- Remove `any` types\n- Add Fastify type augmentation\n- Create proper request/response types\n- Remove `as any` casts\n- Enable stricter TypeScript checks\n\nTo avoid splitting work across multiple issues, all TypeScript type safety improvements are consolidated in #93.",
    "number": 131,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/131"
  },
  {
    "title": "[LOW] Create Shared Package for Common Logic",
    "labels": [
      "P3",
      "refactoring",
      "architecture"
    ],
    "body": "Extract duplicated logic into shared package used by API and Worker.\n\n**Current Issue:**\n- Container logic duplicated\n- Status determination repeated\n- Utilities not shared\n\n**Tasks:**\n\n- [ ] Create packages/shared structure\n- [ ] Move container orchestrator and utilities from #97 to shared package\n- [ ] Move status lock logic\n- [ ] Move log scrubber\n- [ ] Update imports in API and Worker\n- [ ] Update package.json dependencies\n\n**Note:** This handles the shared package migration for code from other refactoring issues (especially #97).\n\n**Dependencies:** Best done after #97 (container abstraction) is complete.\n\n**Benefits:**\n- DRY principle\n- Consistent behavior\n- Easier to maintain",
    "number": 132,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/132"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Service Routes to ServiceController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate service-related routes from `server.ts` to `ServiceController` and `service.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `GET /services`\n- `POST /services` (creation)\n- `GET /services/:id`\n- `PATCH /services/:id`\n- `DELETE /services/:id`\n- `GET /services/:id/health`\n- `GET /services/:id/metrics`\n- `GET /services/metrics/stream` (SSE)\n\n**Tasks:**\n- [ ] Implement `ServiceController` using injected repositories and services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/service.routes.ts` and register it in `index.ts`\n- [ ] Ensure all middleware (auth, validation) is correctly applied\n- [ ] Add unit tests for `ServiceController`",
    "synced": true,
    "number": 146,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/146"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Deployment Routes to DeploymentController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate deployment-related routes from `server.ts` to `DeploymentController` and `deployment.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `POST /services/:id/deploy`\n- `POST /services/:id/restart`\n- `GET /services/:id/deployments`\n- `GET /deployments/:id/logs`\n- `GET /deployments/:id/logs/stream` (SSE)\n\n**Tasks:**\n- [ ] Implement `DeploymentController` using injected repositories and services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/deployment.routes.ts` and register it in `index.ts`\n- [ ] Ensure all middleware (auth, validation) is correctly applied\n- [ ] Add unit tests for `DeploymentController`",
    "synced": true,
    "number": 147,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/147"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate GitHub Proxy Routes to GitHubController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate GitHub proxy routes from `server.ts` to `GitHubController` and `github.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `GET /github/orgs`\n- `GET /github/repos`\n- `GET /github/repos/:owner/:name/branches`\n\n**Tasks:**\n- [ ] Implement `GitHubController` using injected services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/github.routes.ts` and register it in `index.ts`\n- [ ] Ensure GitHub API error handling is preserved\n- [ ] Add unit tests for `GitHubController`",
    "synced": true,
    "number": 148,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/148"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Webhook Routes to WebhookController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate GitHub webhook routes from `server.ts` to `WebhookController` and `webhook.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `POST /webhooks/github`\n\n**Tasks:**\n- [ ] Implement `WebhookController` and move signature verification logic\n- [ ] Move PR and Push event handling logic to controller methods\n- [ ] Create `apps/api/src/routes/webhook.routes.ts` and register it in `index.ts`\n- [ ] Ensure raw body parsing for signature verification is correctly handled in the new structure\n- [ ] Add unit tests for `WebhookController`",
    "synced": true,
    "number": 149,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/149"
  },
  {
    "title": "[MEDIUM] Standardize Zod Error Handling with z.treeifyError()",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "dx"
    ],
    "body": "Currently, controllers manually map ZodError issues into a flat array. We should migrate all controllers to use `z.treeifyError()` (formerly `error.flatten()`) for consistent, structured error responses that match the request body shape.\n\n**Benefits:**\n- zero boilerplate in error handlers\n- structured nested errors for complex forms\n- easier for frontend to map errors to specific fields\n\n**Tasks:**\n- [ ] Update `ServiceController.ts` to use `z.treeifyError()`\n- [ ] Update `FeatureFlagController.ts` to use `z.treeifyError()`\n- [ ] Audit and update any other controllers using Zod validation\n- [ ] Update Dashboard error handling to support the tree-like structure",
    "number": 167,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/167"
  },
  {
    "title": "[HIGH] Insecure Password Hashing Using SHA-256 Without Salt",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "The admin user password hashing uses SHA-256 without salt, which is cryptographically weak and vulnerable to rainbow table attacks.\n\n**Locations:**\n- `apps/api/src/services/InitializationService.ts:111-113`\n- `apps/api/src/services/AuthenticationService.ts:40`\n\n**Current Code:**\n\n```typescript\nprivate hashPassword(password: string): string {\n  // TODO: In a real production app, use bcrypt or argon2 with a proper salt\n  return crypto.createHash('sha256').update(password).digest('hex');\n}\n```\n\n**Security Impact:**\n\n- Passwords vulnerable to rainbow table attacks\n- No salt means identical passwords have identical hashes\n- SHA-256 is too fast for password hashing (allows brute-force attacks)\n- Violates OWASP password storage guidelines\n\n**Recommended Fix:**\n\n```typescript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;\n\nasync hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install bcrypt or argon2 dependency\n- [ ] Implement proper password hashing with salt\n- [ ] Update InitializationService to use secure hashing\n- [ ] Update AuthenticationService to use secure verification\n- [ ] Create migration path for existing passwords\n- [ ] Add tests for password hashing\n- [ ] Document password requirements",
    "state": "CLOSED",
    "synced": true,
    "number": 183,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/183"
  },
  {
    "title": "[HIGH] Duplicate Docker Client Instantiation on Every Request",
    "labels": [
      "P1",
      "performance",
      "bug"
    ],
    "body": "Docker client is instantiated inside controller methods on every request, creating performance overhead and potential resource leaks.\n\n**Locations:**\n- `apps/api/src/controllers/ServiceController.ts:62-64, 102-104, 272-274, 386-387`\n- `apps/api/src/controllers/DeploymentController.ts:100-101, 225-226`\n\n**Current Code:**\n\n```typescript\nasync getAllServices(request: FastifyRequest) {\n  // ...\n  const Docker = (await import('dockerode')).default;\n  const docker = new Docker(); // Created on every request!\n  // ...\n}\n```\n\n**Performance Impact:**\n\n- Unnecessary dynamic imports on every request\n- Creates new Docker client connections repeatedly\n- Memory overhead from multiple client instances\n- Potential connection pool exhaustion\n\n**Recommended Fix:**\n\n```typescript\n// Inject Docker client via DI container\n@injectable()\nexport class ServiceController {\n  constructor(\n    @inject(Symbol.for('IContainerOrchestrator'))\n    private containerOrchestrator: IContainerOrchestrator,\n    // ...\n  ) {}\n\n  async getAllServices(request: FastifyRequest) {\n    const containers = await this.containerOrchestrator.listContainers({ all: true });\n    // ...\n  }\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove dynamic Docker imports from controllers\n- [ ] Use injected IContainerOrchestrator throughout controllers\n- [ ] Ensure Docker client is singleton in DI container\n- [ ] Add tests to verify Docker client reuse\n- [ ] Measure performance improvement",
    "state": "CLOSED",
    "synced": true,
    "number": 184,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/184"
  },
  {
    "title": "[MEDIUM] Direct Prisma Imports in Controllers Bypass DI",
    "labels": [
      "P2",
      "architecture",
      "refactoring"
    ],
    "body": "Several controllers import Prisma directly instead of using injected repositories, breaking dependency injection principles and making testing difficult.\n\n**Locations:**\n- `apps/api/src/controllers/ServiceController.ts:380-381, 419-420, 516-519`\n- `apps/api/src/controllers/DeploymentController.ts:84-85, 219-220`\n- `apps/api/src/controllers/AuthController.ts:235-238`\n\n**Current Code:**\n\n```typescript\nasync getServiceHealth(request: FastifyRequest, reply: FastifyReply) {\n  // ...\n  const { prisma } = await import('database');\n  const service = await prisma.service.findFirst({\n    where: { id, userId: user.id, deletedAt: null },\n  });\n  // ...\n}\n```\n\n**Issues:**\n\n- Breaks dependency injection pattern\n- Makes unit testing difficult (can't mock Prisma)\n- Inconsistent with the rest of the codebase\n- Dynamic imports add unnecessary overhead\n\n**Recommended Fix:**\n\n```typescript\nasync getServiceHealth(request: FastifyRequest, reply: FastifyReply) {\n  // ...\n  const service = await this.serviceRepository.findById(id);\n  if (!service || service.userId !== user.id || service.deletedAt) {\n    return reply.status(404).send({ error: 'Service not found' });\n  }\n  // ...\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove all direct Prisma imports from controllers\n- [ ] Use injected repositories consistently\n- [ ] Add missing repository methods if needed\n- [ ] Update unit tests to use mocked repositories\n- [ ] Document DI pattern in codebase guidelines",
    "state": "CLOSED",
    "synced": true,
    "number": 185,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/185"
  },
  {
    "title": "[MEDIUM] Missing Input Validation for Protection Toggle Endpoint",
    "labels": [
      "P2",
      "security",
      "bug"
    ],
    "body": "The protection toggle endpoint manually validates the `deleteProtected` field without using Zod schema validation, inconsistent with other endpoints.\n\n**Location:**\n`apps/api/src/controllers/ServiceController.ts:352-355`\n\n**Current Code:**\n\n```typescript\nconst { deleteProtected } = request.body as { deleteProtected?: boolean };\n\nif (typeof deleteProtected !== 'boolean') {\n  return reply.status(400).send({ error: 'deleteProtected must be a boolean' });\n}\n```\n\n**Issues:**\n\n- Manual type assertion bypasses type safety\n- Inconsistent with Zod validation used elsewhere\n- Error format differs from other validation errors\n- Missing comprehensive input sanitization\n\n**Recommended Fix:**\n\n```typescript\nconst ProtectionToggleSchema = z.object({\n  deleteProtected: z.boolean(),\n});\n\nasync toggleProtection(request: FastifyRequest, reply: FastifyReply) {\n  let validatedData;\n  try {\n    validatedData = ProtectionToggleSchema.parse(request.body);\n  } catch (error) {\n    if (error instanceof ZodError) {\n      return reply.status(400).send({\n        error: 'Validation failed',\n        details: formatZodError(error),\n      });\n    }\n    throw error;\n  }\n  // ...\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create Zod schema for protection toggle\n- [ ] Use consistent validation pattern with other endpoints\n- [ ] Return consistent error format\n- [ ] Add tests for validation edge cases",
    "state": "CLOSED",
    "synced": true,
    "number": 186,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/186"
  },
  {
    "title": "[MEDIUM] Potential Race Condition in Organization Creation During GitHub Auth",
    "labels": [
      "P2",
      "bug",
      "concurrency"
    ],
    "body": "During GitHub authentication, personal organization creation happens without proper concurrency control, potentially creating duplicate organizations.\n\n**Location:**\n`apps/api/src/services/AuthenticationService.ts:99-104`\n\n**Current Code:**\n\n```typescript\n// Check if user has organizations, if not create a personal one\nconst userOrgs = await this.organizationService.getUserOrganizations(user.id);\nif (userOrgs.length === 0) {\n  await this.organizationService.createOrganization(`${user.username}'s Personal`, user.id);\n}\n```\n\n**Issues:**\n\n- Time-of-check to time-of-use (TOCTOU) vulnerability\n- Concurrent auth requests could create multiple organizations\n- No transaction wrapping the check-and-create operation\n- TODO comment in code acknowledges this issue\n\n**Recommended Fix:**\n\n```typescript\n// Use transaction with upsert pattern\nawait prisma.$transaction(async (tx) => {\n  const existingOrg = await tx.organization.findFirst({\n    where: {\n      members: {\n        some: { userId: user.id, role: Role.OWNER }\n      }\n    }\n  });\n  \n  if (!existingOrg) {\n    await this.organizationService.createOrganization(\n      `${user.username}'s Personal`,\n      user.id,\n      tx\n    );\n  }\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Wrap organization check-and-create in transaction\n- [ ] Use database constraints to prevent duplicates\n- [ ] Add unique constraint for user's personal organization\n- [ ] Add tests for concurrent authentication scenarios\n- [ ] Remove TODO comment after fixing",
    "state": "CLOSED",
    "synced": true,
    "number": 187,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/187"
  },
  {
    "title": "[MEDIUM] SSE Connection Cleanup May Leave Redis Subscriptions",
    "labels": [
      "P2",
      "bug",
      "reliability"
    ],
    "body": "In the deployment logs SSE endpoint, Redis subscription cleanup uses a shared connection for both subscribe and unsubscribe, which may not properly clean up subscriptions.\n\n**Location:**\n`apps/api/src/controllers/DeploymentController.ts:361-398`\n\n**Current Code:**\n\n```typescript\nconst subConnection = request.server.redis;\nconst channel = `deployment-logs:${id}`;\n\n// ...\n\nconst cleanup = async () => {\n  // ...\n  if (isSubscribed) {\n    try {\n      subConnection.removeListener('message', onMessage);\n      await subConnection.unsubscribe(channel);\n      isSubscribed = false;\n    } catch (err) {\n      console.error(`Error unsubscribing from channel ${channel}:`, err);\n    }\n  }\n};\n```\n\n**Issues:**\n\n- Using shared Redis connection for pub/sub can cause issues\n- Redis pub/sub requires dedicated connections\n- Subscription may not be properly cleaned up on connection errors\n- Could lead to memory leaks in Redis\n\n**Recommended Fix:**\n\n```typescript\n// Create dedicated subscriber connection\nconst subConnection = request.server.redis.duplicate();\n\nconst cleanup = async () => {\n  // ...\n  try {\n    await subConnection.unsubscribe(channel);\n    await subConnection.quit(); // Close dedicated connection\n  } catch (err) {\n    console.error(`Error cleaning up Redis subscription:`, err);\n  }\n};\n```\n\n**Acceptance Criteria:**\n\n- [ ] Use dedicated Redis connections for pub/sub\n- [ ] Properly close dedicated connections on cleanup\n- [ ] Add connection health monitoring\n- [ ] Add tests for subscription cleanup\n- [ ] Document Redis pub/sub pattern",
    "state": "CLOSED",
    "synced": true,
    "number": 188,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/188"
  },
  {
    "title": "[MEDIUM] Feature Flag Client Makes Individual API Calls for Each Flag",
    "labels": [
      "P2",
      "performance",
      "frontend"
    ],
    "body": "The FeatureFlagClient's `checkMultiple` method makes separate API calls for each feature flag instead of batching them into a single request.\n\n**Location:**\n`apps/dashboard/src/lib/featureFlags.ts:44-54`\n\n**Current Code:**\n\n```typescript\nstatic async checkMultiple(keys: string[], userId?: string): Promise<Record<string, boolean>> {\n  const results: Record<string, boolean> = {};\n\n  await Promise.all(\n    keys.map(async (key) => {\n      results[key] = await this.isEnabled(key, userId);\n    }),\n  );\n\n  return results;\n}\n```\n\n**Performance Impact:**\n\n- N API calls for N feature flags\n- Increased latency for feature flag checks\n- Higher server load\n- Potential rate limiting issues\n\n**Recommended Fix:**\n\n```typescript\n// Backend: Add bulk check endpoint\n// POST /feature-flags/check-bulk\n// Body: { keys: string[], userId?: string }\n\n// Frontend:\nstatic async checkMultiple(keys: string[], userId?: string): Promise<Record<string, boolean>> {\n  try {\n    const response = await fetch(`${API_BASE_URL}/feature-flags/check-bulk`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys, userId }),\n    });\n    \n    if (!response.ok) {\n      return Object.fromEntries(keys.map(k => [k, false]));\n    }\n    \n    return response.json();\n  } catch (error) {\n    return Object.fromEntries(keys.map(k => [k, false]));\n  }\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add bulk feature flag check endpoint to API\n- [ ] Update FeatureFlagClient to use bulk endpoint\n- [ ] Add caching for feature flag results\n- [ ] Add tests for bulk check functionality\n- [ ] Document API endpoint",
    "state": "CLOSED",
    "synced": true,
    "number": 189,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/189"
  },
  {
    "title": "[MEDIUM] Error Boundary Does Not Report Errors to Monitoring Service",
    "labels": [
      "P2",
      "observability",
      "frontend"
    ],
    "body": "The React ErrorBoundary only logs errors to console without reporting to any error monitoring service (e.g., Sentry).\n\n**Location:**\n`apps/dashboard/src/components/ErrorBoundary.tsx:26-28`\n\n**Current Code:**\n\n```typescript\ncomponentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n  console.error('ErrorBoundary caught an error:', error, errorInfo);\n}\n```\n\n**Issues:**\n\n- Production errors are not tracked\n- No visibility into client-side failures\n- Cannot correlate frontend errors with backend issues\n- Missing error context (user, route, etc.)\n\n**Recommended Fix:**\n\n```typescript\nimport * as Sentry from '@sentry/nextjs';\n\ncomponentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n  console.error('ErrorBoundary caught an error:', error, errorInfo);\n  \n  // Report to error monitoring\n  Sentry.captureException(error, {\n    contexts: {\n      react: {\n        componentStack: errorInfo.componentStack,\n      },\n    },\n  });\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Choose and integrate error monitoring service (Sentry recommended)\n- [ ] Update ErrorBoundary to report errors\n- [ ] Add user context to error reports\n- [ ] Add route/page context to error reports\n- [ ] Document error monitoring setup\n- [ ] Add source maps for better stack traces",
    "state": "CLOSED",
    "synced": true,
    "number": 190,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/190"
  },
  {
    "title": "[MEDIUM] Webhook Controller Uses Direct Prisma Import Instead of Repositories",
    "labels": [
      "P2",
      "architecture",
      "refactoring"
    ],
    "body": "The WebhookController imports Prisma directly in several places instead of using injected repositories, creating inconsistency with the DI pattern.\n\n**Location:**\n`apps/api/src/controllers/WebhookController.ts:321-364, 374-379, 422-429`\n\n**Current Code:**\n\n```typescript\nasync handlePullRequestEvent(...) {\n  // ...\n  const { prisma } = await import('database');\n  const baseService = await prisma.service.findFirst({\n    where: { ... },\n  });\n  // ...\n  const service = await prisma.service.upsert({ ... });\n}\n```\n\n**Issues:**\n\n- Inconsistent with DI pattern used elsewhere\n- Dynamic imports add overhead\n- Makes testing difficult\n- Cannot easily mock database in tests\n\n**Recommended Fix:**\n\nUse the injected `IServiceRepository` throughout the controller:\n\n```typescript\nasync handlePullRequestEvent(...) {\n  const baseService = await this.serviceRepository.findByRepoAndBranch(\n    repoUrl,\n    { isPreview: false, deletedAt: null }\n  );\n  // ...\n  const service = await this.serviceRepository.upsertPreview(...);\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove direct Prisma imports from WebhookController\n- [ ] Add necessary methods to IServiceRepository interface\n- [ ] Implement new repository methods\n- [ ] Update tests to use mocked repositories\n- [ ] Follow consistent DI pattern",
    "state": "CLOSED",
    "synced": true,
    "number": 191,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/191"
  },
  {
    "title": "[LOW] Duplicate Constants Definition Between API and Worker",
    "labels": [
      "P3",
      "refactoring",
      "maintainability"
    ],
    "body": "Container resource limit constants are duplicated between API and Worker services, violating DRY principles.\n\n**Locations:**\n- `apps/api/src/config/constants.ts:7-14`\n- `apps/worker/src/config/constants.ts:7-14`\n\n**Current Code (both files):**\n\n```typescript\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\nexport const CONTAINER_MEMORY_LIMIT_BYTES = CONTAINER_MEMORY_LIMIT_MB * 1024 * 1024;\n\nexport const CONTAINER_CPU_CORES = parseFloat(process.env.CONTAINER_CPU_CORES || '1.0');\nexport const CONTAINER_CPU_NANOCPUS = Math.floor(CONTAINER_CPU_CORES * 1000000000);\n```\n\n**Issues:**\n\n- Same constants defined in two places\n- Changes must be made in both files\n- Risk of configuration drift\n- Harder to maintain\n\n**Recommended Fix:**\n\nMove shared constants to the `packages/shared` package:\n\n```typescript\n// packages/shared/src/config/constants.ts\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\n// ...\n\n// apps/api/src/config/constants.ts\nexport { CONTAINER_MEMORY_LIMIT_MB, CONTAINER_CPU_NANOCPUS } from 'shared';\n// ... API-specific constants\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create shared constants file in packages/shared\n- [ ] Move common constants to shared package\n- [ ] Update imports in API and Worker\n- [ ] Remove duplicate definitions\n- [ ] Add tests for shared constants",
    "state": "CLOSED",
    "synced": true,
    "number": 192,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/192"
  },
  {
    "title": "[LOW] Missing Error Handling for Config Parsing in Constants",
    "labels": [
      "P3",
      "reliability",
      "enhancement"
    ],
    "body": "Environment variable parsing in constants files doesn't handle invalid values gracefully, potentially causing silent failures or NaN values.\n\n**Locations:**\n- `apps/api/src/config/constants.ts`\n- `apps/worker/src/config/constants.ts`\n\n**Current Code:**\n\n```typescript\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\nexport const CONTAINER_CPU_CORES = parseFloat(process.env.CONTAINER_CPU_CORES || '1.0');\n```\n\n**Issues:**\n\n- Invalid string values result in NaN\n- No validation of reasonable ranges\n- Silent failures could cause unexpected behavior\n- No logging of configuration issues\n\n**Recommended Fix:**\n\n```typescript\nfunction parseIntEnv(name: string, defaultValue: number, min?: number, max?: number): number {\n  const raw = process.env[name];\n  if (!raw) return defaultValue;\n  \n  const parsed = parseInt(raw, 10);\n  if (isNaN(parsed)) {\n    console.warn(`Invalid ${name} value '${raw}', using default ${defaultValue}`);\n    return defaultValue;\n  }\n  \n  if (min !== undefined && parsed < min) {\n    console.warn(`${name} value ${parsed} below minimum ${min}, using ${min}`);\n    return min;\n  }\n  \n  if (max !== undefined && parsed > max) {\n    console.warn(`${name} value ${parsed} above maximum ${max}, using ${max}`);\n    return max;\n  }\n  \n  return parsed;\n}\n\nexport const CONTAINER_MEMORY_LIMIT_MB = parseIntEnv(\n  'CONTAINER_MEMORY_LIMIT_MB',\n  512,\n  64,    // Minimum 64MB\n  8192   // Maximum 8GB\n);\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create safe parsing utility functions\n- [ ] Add range validation for numeric configs\n- [ ] Log warnings for invalid/out-of-range values\n- [ ] Add tests for edge cases\n- [ ] Document valid configuration ranges",
    "state": "CLOSED",
    "synced": true,
    "number": 193,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/193"
  },
  {
    "title": "[LOW] Hardcoded Platform Domain in Multiple Locations",
    "labels": [
      "P3",
      "maintainability",
      "refactoring"
    ],
    "body": "The platform domain `helvetia.cloud` is hardcoded in multiple places instead of being centrally configured.\n\n**Locations:**\n- `apps/api/src/controllers/DeploymentController.ts:139-140`\n- Various Traefik label configurations\n\n**Current Code:**\n\n```typescript\nconst traefikRule = service.customDomain\n  ? `Host(\\`${service.name}.${process.env.PLATFORM_DOMAIN || 'helvetia.cloud'}\\`) || ...`\n  : `Host(\\`${service.name}.${process.env.PLATFORM_DOMAIN || 'helvetia.cloud'}\\`) || ...`;\n```\n\n**Issues:**\n\n- Domain string repeated with same fallback pattern\n- Risk of inconsistent domain usage\n- Harder to rebrand or deploy to different domains\n- Should be a centralized constant\n\n**Recommended Fix:**\n\n```typescript\n// packages/shared/src/config/constants.ts\nexport const PLATFORM_DOMAIN = process.env.PLATFORM_DOMAIN || 'helvetia.cloud';\n\n// apps/api/src/controllers/DeploymentController.ts\nimport { PLATFORM_DOMAIN } from 'shared';\n\nconst traefikRule = service.customDomain\n  ? `Host(\\`${service.name}.${PLATFORM_DOMAIN}\\`) || ...`\n  : `Host(\\`${service.name}.${PLATFORM_DOMAIN}\\`) || ...`;\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create PLATFORM_DOMAIN constant in shared package\n- [ ] Replace all hardcoded domain references\n- [ ] Document domain configuration\n- [ ] Add validation for domain format",
    "state": "CLOSED",
    "synced": true,
    "number": 194,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/194"
  },
  {
    "title": "[LOW] useFeatureFlag Hook Missing Dependency in useEffect",
    "labels": [
      "P3",
      "frontend",
      "bug"
    ],
    "body": "The `useFeatureFlag` hook's useEffect may have stale closure issues due to missing dependencies in the dependency array.\n\n**Location:**\n`apps/dashboard/src/lib/featureFlags.ts:68-79`\n\n**Current Code:**\n\n```typescript\nexport function useFeatureFlag(\n  key: string,\n  userId?: string,\n  options: { enabled?: boolean } = { enabled: true },\n) {\n  const [enabled, setEnabled] = React.useState<boolean>(false);\n  const [loading, setLoading] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    if (!options.enabled) {\n      setEnabled(false);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    FeatureFlagClient.isEnabled(key, userId)\n      .then(setEnabled)\n      .finally(() => setLoading(false));\n  }, [key, userId, options.enabled]);\n\n  return { enabled, loading };\n}\n```\n\n**Issues:**\n\n- `options.enabled` should be extracted before the effect\n- Default parameter creates new object on each render\n- Could cause unnecessary re-renders\n\n**Recommended Fix:**\n\n```typescript\nexport function useFeatureFlag(\n  key: string,\n  userId?: string,\n  options?: { enabled?: boolean },\n) {\n  const isEnabled = options?.enabled ?? true;\n  const [enabled, setEnabled] = React.useState<boolean>(false);\n  const [loading, setLoading] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    if (!isEnabled) {\n      setEnabled(false);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    FeatureFlagClient.isEnabled(key, userId)\n      .then(setEnabled)\n      .finally(() => setLoading(false));\n  }, [key, userId, isEnabled]);\n\n  return { enabled, loading };\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Fix options parameter handling\n- [ ] Extract enabled flag before useEffect\n- [ ] Ensure stable dependencies\n- [ ] Add tests for hook behavior",
    "state": "CLOSED",
    "synced": true,
    "number": 195,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/195"
  },
  {
    "title": "[LOW] Services Hook Returns Status String Instead of Proper Enum Type",
    "labels": [
      "P3",
      "type-safety",
      "frontend"
    ],
    "body": "The `createUpdateServiceMetrics` function casts metrics status to `ServiceStatus` without proper type checking, potentially allowing invalid status values.\n\n**Location:**\n`apps/dashboard/src/hooks/useServices.ts:279-296`\n\n**Current Code:**\n\n```typescript\nexport function createUpdateServiceMetrics(queryClient: ReturnType<typeof useQueryClient>) {\n  return (updates: Array<{ id: string; metrics: Service['metrics']; status?: ServiceStatus }>) => {\n    queryClient.setQueryData<Service[]>(serviceKeys.lists(), (old) =>\n      old\n        ? old.map((service) => {\n            const update = updates.find((u) => u.id === service.id);\n            if (update && update.metrics) {\n              return {\n                ...service,\n                metrics: update.metrics,\n                status: (update.metrics.status as ServiceStatus) || service.status,\n              };\n            }\n            return service;\n          })\n        : old,\n    );\n  };\n}\n```\n\n**Issues:**\n\n- Unsafe type assertion `as ServiceStatus`\n- Could result in invalid status values in state\n- No runtime validation of status values\n\n**Recommended Fix:**\n\n```typescript\nconst VALID_STATUSES: ServiceStatus[] = ['IDLE', 'DEPLOYING', 'RUNNING', 'STOPPED', 'FAILED'];\n\nfunction isValidStatus(status: unknown): status is ServiceStatus {\n  return typeof status === 'string' && VALID_STATUSES.includes(status as ServiceStatus);\n}\n\nexport function createUpdateServiceMetrics(queryClient: ReturnType<typeof useQueryClient>) {\n  return (updates: Array<{ id: string; metrics: Service['metrics']; status?: ServiceStatus }>) => {\n    queryClient.setQueryData<Service[]>(serviceKeys.lists(), (old) =>\n      old?.map((service) => {\n        const update = updates.find((u) => u.id === service.id);\n        if (update?.metrics) {\n          const newStatus = update.metrics.status;\n          return {\n            ...service,\n            metrics: update.metrics,\n            status: isValidStatus(newStatus) ? newStatus : service.status,\n          };\n        }\n        return service;\n      }) ?? old,\n    );\n  };\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add runtime status validation\n- [ ] Create type guard for ServiceStatus\n- [ ] Remove unsafe type assertions\n- [ ] Add tests for status updates",
    "state": "CLOSED",
    "synced": true,
    "number": 196,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/196"
  },
  {
    "title": "[MEDIUM] Theme Switcher Implementation",
    "labels": [
      "P2",
      "enhancement",
      "ui/ux",
      "frontend"
    ],
    "body": "Allow users to manually switch between light and dark themes in the main menu, independent of system preferences.\n\n**Current State:**\n- Dark/Light mode exists with system-aware theming support\n- No manual theme switcher UI component\n\n**Requirements:**\n\n- Add theme switcher toggle/button to main menu\n- Persist user's theme preference (localStorage/cookies)\n- Override system theme when user has explicit preference\n- Smooth transitions between themes\n- Accessible controls with proper ARIA labels\n\n**Acceptance Criteria:**\n\n- [ ] Design theme switcher component (toggle or dropdown)\n- [ ] Add theme switcher to main menu/navigation\n- [ ] Implement theme state management\n- [ ] Persist theme preference across sessions\n- [ ] Handle system theme vs user preference priority\n- [ ] Add smooth theme transition animations\n- [ ] Ensure accessibility (keyboard navigation, ARIA labels)\n- [ ] Test on all pages and components\n- [ ] Update documentation",
    "state": "OPEN",
    "synced": true,
    "number": 227,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/227"
  },
  {
    "title": "[MEDIUM] Modern Login Page Design",
    "labels": [
      "P2",
      "enhancement",
      "ui/ux",
      "frontend"
    ],
    "body": "Create a modern, engaging login page that matches the platform's premium glassmorphic aesthetic.\n\n**Current State:**\n- GitHub OAuth integration is complete\n- Login flow is functional\n- Login page needs visual polish and branding\n\n**Requirements:**\n\n- Premium glassmorphic design consistent with landing page\n- Clear value proposition and call-to-action\n- GitHub OAuth button with appropriate branding\n- Responsive design for all screen sizes\n- Loading states and error handling\n- Optional: Email/password login for admin accounts\n\n**Design Elements:**\n\n- Platform logo and branding\n- Hero section with key benefits\n- Prominent \"Sign in with GitHub\" button\n- Security/privacy messaging\n- Links to Terms of Service and Privacy Policy\n- Mobile-friendly layout\n\n**Acceptance Criteria:**\n\n- [ ] Design login page mockup\n- [ ] Implement glassmorphic UI components\n- [ ] Add GitHub OAuth button with proper styling\n- [ ] Include security/privacy messaging\n- [ ] Implement loading and error states\n- [ ] Ensure mobile responsiveness\n- [ ] Add proper meta tags for SEO\n- [ ] Test authentication flow\n- [ ] Accessibility compliance (WCAG 2.1 AA)\n- [ ] Update screenshots in documentation",
    "state": "OPEN",
    "synced": true,
    "number": 228,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/228"
  },
  {
    "title": "[HIGH] Team Collaboration & Organizations",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "backend",
      "frontend"
    ],
    "body": "Implement team collaboration features including organizations, member management, and Role-Based Access Control (RBAC).\n\n**Current State:**\n- Single-user accounts only\n- No team or organization support\n- Basic user authentication exists\n\n**Features Required:**\n\n### Organizations\n- Create and manage organizations\n- Organization settings (name, avatar, billing)\n- Transfer services between personal and org accounts\n\n### Member Management\n- Invite members via email\n- Accept/decline invitations\n- Remove members\n- View member activity\n\n### RBAC (Role-Based Access Control)\n- Owner: Full admin access\n- Admin: Manage members and services\n- Developer: Deploy and manage services\n- Viewer: Read-only access\n\n### Permissions\n- Service-level permissions\n- Deployment permissions\n- Settings and billing access control\n\n**Database Schema Changes:**\n\n```prisma\nmodel Organization {\n  id        String   @id @default(cuid())\n  name      String\n  slug      String   @unique\n  avatar    String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  members   OrganizationMember[]\n  services  Service[]\n}\n\nmodel OrganizationMember {\n  id             String   @id @default(cuid())\n  organizationId String\n  userId         String\n  role           Role\n  createdAt      DateTime @default(now())\n  updatedAt      DateTime @updatedAt\n\n  organization Organization @relation(fields: [organizationId], references: [id])\n  user         User         @relation(fields: [userId], references: [id])\n\n  @@unique([organizationId, userId])\n}\n\nenum Role {\n  OWNER\n  ADMIN\n  DEVELOPER\n  VIEWER\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Design organization data model\n- [ ] Create database migrations\n- [ ] Implement organization CRUD APIs\n- [ ] Implement member management APIs\n- [ ] Add RBAC middleware for permission checks\n- [ ] Create organization dashboard UI\n- [ ] Build member invitation system\n- [ ] Add role management interface\n- [ ] Update service creation to support organizations\n- [ ] Add organization context switching\n- [ ] Implement audit logging for org actions\n- [ ] Add comprehensive tests\n- [ ] Update documentation\n- [ ] Migration path for existing users",
    "state": "OPEN",
    "synced": true,
    "number": 229,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/229"
  },
  {
    "title": "[HIGH] Billing Integration with Stripe",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "backend",
      "frontend",
      "billing"
    ],
    "body": "Integrate Stripe for usage-based pricing and subscription management.\n\n**Current State:**\n- No billing or payment system\n- All services are free\n- No resource usage tracking for billing\n\n**Pricing Model:**\n\n- Free tier with limitations\n- Usage-based pricing (compute hours, memory, bandwidth)\n- Subscription tiers (Starter, Pro, Enterprise)\n- Pay-as-you-go option\n\n**Features Required:**\n\n### Stripe Integration\n- Stripe account connection\n- Payment method management\n- Subscription creation and updates\n- Usage-based billing\n- Invoice generation\n\n### Usage Tracking\n- Track compute hours per service\n- Track memory usage\n- Track bandwidth/data transfer\n- Track database storage\n- Real-time usage monitoring\n\n### Billing Dashboard\n- Current usage and costs\n- Payment history\n- Invoices and receipts\n- Usage forecasts\n- Upgrade/downgrade plans\n\n### Enforcement\n- Resource limits per tier\n- Graceful degradation for unpaid accounts\n- Automatic service suspension\n- Payment retry logic\n\n**Database Schema:**\n\n```prisma\nmodel Subscription {\n  id                 String   @id @default(cuid())\n  userId             String?\n  organizationId     String?\n  stripeCustomerId   String   @unique\n  stripeSubscriptionId String? @unique\n  plan               SubscriptionPlan\n  status             SubscriptionStatus\n  currentPeriodStart DateTime\n  currentPeriodEnd   DateTime\n  createdAt          DateTime @default(now())\n  updatedAt          DateTime @updatedAt\n\n  user         User?         @relation(fields: [userId], references: [id])\n  organization Organization? @relation(fields: [organizationId], references: [id])\n}\n\nenum SubscriptionPlan {\n  FREE\n  STARTER\n  PRO\n  ENTERPRISE\n}\n\nenum SubscriptionStatus {\n  ACTIVE\n  PAST_DUE\n  CANCELED\n  UNPAID\n}\n\nmodel UsageRecord {\n  id          String   @id @default(cuid())\n  serviceId   String\n  metric      UsageMetric\n  quantity    Float\n  timestamp   DateTime\n  periodStart DateTime\n  periodEnd   DateTime\n\n  service Service @relation(fields: [serviceId], references: [id])\n}\n\nenum UsageMetric {\n  COMPUTE_HOURS\n  MEMORY_GB_HOURS\n  BANDWIDTH_GB\n  STORAGE_GB\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Set up Stripe account and API keys\n- [ ] Implement Stripe webhook handlers\n- [ ] Create subscription management APIs\n- [ ] Build usage tracking system\n- [ ] Implement metering for billable resources\n- [ ] Create billing dashboard UI\n- [ ] Add payment method management\n- [ ] Implement plan upgrade/downgrade\n- [ ] Add invoice viewing and download\n- [ ] Implement resource limit enforcement\n- [ ] Add grace period for failed payments\n- [ ] Create admin billing tools\n- [ ] Add comprehensive tests\n- [ ] Document pricing structure\n- [ ] Legal review of terms\n- [ ] PCI compliance verification",
    "state": "OPEN",
    "synced": true,
    "number": 230,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/230"
  },
  {
    "title": "[MEDIUM] One-Click Application Marketplace",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "backend",
      "frontend"
    ],
    "body": "Create a marketplace for one-click deployment of popular open-source applications.\n\n**Current State:**\n- Users manually configure services\n- No template or marketplace system\n- Each deployment requires full configuration\n\n**Applications to Include:**\n\n- **Content Management:** WordPress, Ghost, Strapi\n- **Analytics:** Plausible, Umami, Matomo\n- **Databases:** PostgreSQL, MySQL, Redis, MongoDB\n- **Development Tools:** GitLab, Jenkins, SonarQube\n- **Communication:** Mattermost, Rocket.Chat\n- **E-commerce:** WooCommerce, Magento\n- **Project Management:** Taiga, Wekan\n- **Monitoring:** Grafana, Prometheus\n\n**Features:**\n\n### Marketplace UI\n- Browse available applications\n- Search and filter by category\n- Application details and requirements\n- User ratings and reviews\n- Quick deploy button\n\n### Application Templates\n- Pre-configured Docker Compose files\n- Environment variable templates\n- Default resource allocations\n- Health check configurations\n- Documentation links\n\n### One-Click Deploy\n- Guided setup wizard\n- Automatic dependency resolution\n- Environment variable input\n- Domain configuration\n- SSL certificate generation\n\n### Template Management\n- Community-contributed templates\n- Official verified templates\n- Template versioning\n- Update notifications\n\n**Database Schema:**\n\n```prisma\nmodel ApplicationTemplate {\n  id          String   @id @default(cuid())\n  name        String\n  slug        String   @unique\n  description String\n  category    String\n  icon        String\n  author      String\n  official    Boolean  @default(false)\n  version     String\n  minMemory   Int      // MB\n  minCpu      Float\n  compose     String   // Docker Compose YAML\n  envVars     Json     // Required env vars with descriptions\n  ports       Json     // Exposed ports\n  volumes     Json     // Required volumes\n  readme      String\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  deployments Service[]\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Design marketplace UI/UX\n- [ ] Create application template schema\n- [ ] Build template management system\n- [ ] Add 10+ popular application templates\n- [ ] Implement one-click deploy workflow\n- [ ] Create guided setup wizard\n- [ ] Add search and filtering\n- [ ] Implement application categories\n- [ ] Add template versioning\n- [ ] Create template contribution guide\n- [ ] Add template validation and security scanning\n- [ ] Implement user reviews/ratings\n- [ ] Add template update notifications\n- [ ] Write documentation for each template\n- [ ] Add comprehensive tests",
    "state": "OPEN",
    "synced": true,
    "number": 231,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/231"
  },
  {
    "title": "[MEDIUM] Helvetia Cloud CLI Tool",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "cli",
      "developer-experience"
    ],
    "body": "Create a specialized command-line tool for Helvetia Cloud to enable developers to manage services, deployments, and resources from the terminal.\n\n**Current State:**\n- Web dashboard only\n- No CLI tool\n- Manual API calls for automation\n\n**Core Features:**\n\n### Authentication\n```bash\nhelvetia login\nhelvetia logout\nhelvetia whoami\n```\n\n### Service Management\n```bash\nhelvetia services list\nhelvetia services create <name> --repo <url> --branch <branch>\nhelvetia services get <id>\nhelvetia services update <id> --env KEY=VALUE\nhelvetia services delete <id>\nhelvetia services logs <id> --follow\nhelvetia services metrics <id>\n```\n\n### Deployments\n```bash\nhelvetia deploy <service-id>\nhelvetia deployments list <service-id>\nhelvetia deployments logs <deployment-id>\nhelvetia rollback <service-id> <deployment-id>\n```\n\n### Databases\n```bash\nhelvetia db create postgres --name mydb\nhelvetia db list\nhelvetia db connect <db-id>\nhelvetia db backup <db-id>\nhelvetia db restore <db-id> <backup-id>\n```\n\n### Environment Variables\n```bash\nhelvetia env list <service-id>\nhelvetia env set <service-id> KEY=VALUE\nhelvetia env unset <service-id> KEY\nhelvetia env pull <service-id> --file .env\nhelvetia env push <service-id> --file .env\n```\n\n### Domains\n```bash\nhelvetia domains list <service-id>\nhelvetia domains add <service-id> <domain>\nhelvetia domains remove <service-id> <domain>\n```\n\n### Organizations\n```bash\nhelvetia orgs list\nhelvetia orgs switch <org-id>\nhelvetia orgs members list <org-id>\nhelvetia orgs members add <org-id> <email> --role developer\n```\n\n**Technical Requirements:**\n\n- Written in Go or Node.js\n- Cross-platform (Windows, macOS, Linux)\n- Interactive and non-interactive modes\n- Colored output and progress indicators\n- Configuration file support (~/.helvetia/config.yaml)\n- API token management\n- Auto-completion for shells (bash, zsh, fish)\n- Update notifications\n\n**Additional Features:**\n\n- `helvetia init` - Initialize a new project\n- `helvetia status` - Show service health status\n- `helvetia scale <service-id> --replicas 3` - Scale services\n- `helvetia exec <service-id> -- <command>` - Execute commands in container\n- `helvetia port-forward <service-id> 8080:80` - Port forwarding\n- `helvetia marketplace list` - Browse marketplace templates\n- `helvetia marketplace deploy <template>` - Deploy from marketplace\n\n**Acceptance Criteria:**\n\n- [ ] Choose technology stack (Go/Node.js)\n- [ ] Set up CLI project structure\n- [ ] Implement authentication flow\n- [ ] Build service management commands\n- [ ] Add deployment commands\n- [ ] Implement database commands\n- [ ] Add environment variable management\n- [ ] Implement organization commands\n- [ ] Add interactive prompts for common tasks\n- [ ] Create configuration file system\n- [ ] Add shell auto-completion\n- [ ] Implement colored output and formatting\n- [ ] Add progress indicators\n- [ ] Create installation scripts\n- [ ] Publish to package managers (npm, brew, apt)\n- [ ] Write comprehensive documentation\n- [ ] Add unit and integration tests\n- [ ] Create demo video/GIF",
    "state": "OPEN",
    "synced": true,
    "number": 232,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/232"
  },
  {
    "title": "[HIGH] Comprehensive API Documentation",
    "labels": [
      "P1",
      "documentation",
      "enhancement"
    ],
    "body": "Create comprehensive API documentation for the Helvetia Cloud platform to enable third-party integrations and developer adoption.\n\n**Current State:**\n- No public API documentation\n- Endpoints are not formally documented\n- No API reference or interactive explorer\n\n**Documentation Requirements:**\n\n### API Reference\n- Complete endpoint listing\n- Request/response schemas\n- Authentication methods\n- Error codes and messages\n- Rate limiting details\n- Versioning strategy\n\n### Interactive Documentation\n- OpenAPI/Swagger specification\n- Try-it-out functionality\n- Code examples in multiple languages\n- Authentication playground\n\n### Getting Started Guide\n- Quick start tutorial\n- Authentication setup\n- Common use cases\n- Best practices\n- SDK installation (if available)\n\n**Technology Options:**\n\n- **OpenAPI/Swagger**: Industry standard, great tooling\n- **Redoc**: Clean, responsive documentation\n- **Docusaurus**: Full documentation site\n- **Stoplight**: API design and documentation\n\n**Endpoints to Document:**\n\n### Authentication\n- POST /auth/github\n- POST /auth/logout\n- GET /auth/verify\n\n### Services\n- GET /services\n- POST /services\n- GET /services/:id\n- PATCH /services/:id\n- DELETE /services/:id\n- POST /services/:id/deploy\n- GET /services/:id/metrics\n- GET /services/:id/logs\n\n### Deployments\n- GET /deployments\n- GET /deployments/:id\n- GET /deployments/:id/logs\n\n### Databases\n- GET /databases\n- POST /databases\n- GET /databases/:id\n- DELETE /databases/:id\n\n### Organizations (future)\n- GET /organizations\n- POST /organizations\n- GET /organizations/:id/members\n- POST /organizations/:id/members\n\n### Webhooks\n- POST /webhooks/github\n\n**Acceptance Criteria:**\n\n- [ ] Generate OpenAPI specification from code\n- [ ] Set up documentation site (Redoc/Stoplight)\n- [ ] Document all public API endpoints\n- [ ] Add request/response examples\n- [ ] Include authentication guide\n- [ ] Document error codes\n- [ ] Add rate limiting information\n- [ ] Create getting started tutorial\n- [ ] Add code examples (cURL, JavaScript, Python)\n- [ ] Include webhook documentation\n- [ ] Add API versioning strategy\n- [ ] Create SDKs for popular languages (optional)\n- [ ] Set up automatic documentation updates\n- [ ] Add API changelog\n- [ ] Include security best practices\n- [ ] Make documentation publicly accessible",
    "state": "OPEN",
    "synced": true,
    "number": 233,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/233"
  },
  {
    "title": "[HIGH] User Documentation & Guides",
    "labels": [
      "P1",
      "documentation",
      "enhancement",
      "user-experience"
    ],
    "body": "Create comprehensive user documentation to help users understand and effectively use the Helvetia Cloud platform.\n\n**Current State:**\n- Limited documentation\n- No user guides or tutorials\n- Only developer-focused README\n\n**Documentation Structure:**\n\n### Getting Started\n- Platform overview\n- Account creation\n- First deployment tutorial\n- Dashboard walkthrough\n- Basic concepts (services, deployments, environments)\n\n### How-To Guides\n- Deploy a Node.js application\n- Deploy a static site (React, Vue, Angular)\n- Deploy a Docker application\n- Deploy a database\n- Set up custom domains\n- Configure SSL certificates\n- Manage environment variables\n- View logs and metrics\n- Set up webhooks for auto-deployment\n- Create preview environments\n- Scale services\n- Backup and restore databases\n\n### Service Types\n- Docker services\n- Static site services\n- Database services (PostgreSQL, MySQL, Redis)\n- Docker Compose services\n- Preview environments\n\n### Features\n- Real-time logs streaming\n- Container metrics and monitoring\n- Zero-downtime deployments\n- Health checks\n- Custom domains\n- Environment variable management\n- GitHub integration\n- Webhook automation\n\n### Best Practices\n- Security guidelines\n- Performance optimization\n- Resource allocation\n- Environment management\n- CI/CD integration\n- Monitoring and alerting\n\n### Troubleshooting\n- Common deployment issues\n- Build failures\n- Container crashes\n- Connection problems\n- Performance issues\n- FAQ\n\n### Reference\n- Environment variables\n- Docker image requirements\n- Resource limits\n- Port configuration\n- Health check configuration\n- Supported frameworks and languages\n\n**Documentation Platform:**\n\nOptions:\n- **Docusaurus**: Full-featured documentation site\n- **GitBook**: Beautiful, easy-to-use\n- **Read the Docs**: Classic documentation hosting\n- **Custom Next.js site**: Full control, matches branding\n\n**Features:**\n\n- Search functionality\n- Version support\n- Dark/light mode\n- Mobile responsive\n- Code syntax highlighting\n- Interactive examples\n- Video tutorials\n- Screenshots and GIFs\n- Multi-language support (EN, DE, FR, IT)\n\n**Acceptance Criteria:**\n\n- [ ] Choose documentation platform\n- [ ] Set up documentation site structure\n- [ ] Write Getting Started guide\n- [ ] Create deployment tutorials for each service type\n- [ ] Document all platform features\n- [ ] Add troubleshooting guides\n- [ ] Include best practices documentation\n- [ ] Add screenshots and diagrams\n- [ ] Create video tutorials (optional)\n- [ ] Implement search functionality\n- [ ] Ensure mobile responsiveness\n- [ ] Add multi-language support\n- [ ] Set up feedback mechanism\n- [ ] Create table of contents and navigation\n- [ ] Add related articles linking\n- [ ] Include glossary of terms\n- [ ] Make documentation publicly accessible\n- [ ] Set up analytics to track usage",
    "state": "OPEN",
    "synced": true,
    "number": 234,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/234"
  },
  {
    "title": "[HIGH] Privacy Policy",
    "labels": [
      "P1",
      "legal",
      "compliance",
      "documentation"
    ],
    "body": "Create a comprehensive privacy policy for the Helvetia Cloud platform to ensure GDPR and DSGVO compliance and build user trust.\n\n**Current State:**\n- No privacy policy\n- GDPR and DSGVO compliance implemented in code\n- No public documentation of data practices\n\n**Requirements:**\n\n### Legal Framework\n- GDPR (General Data Protection Regulation) compliant\n- DSGVO (Datenschutz-Grundverordnung) compliant\n- Swiss data protection law compliant\n- ePrivacy Directive compliant\n\n### Content to Include:\n\n#### 1. Introduction\n- Who we are\n- Contact information\n- Data controller details\n\n#### 2. Data We Collect\n- Account information (email, username, GitHub profile)\n- Service data (repositories, deployments, logs)\n- Usage data (analytics, metrics)\n- Technical data (IP addresses, browser info)\n- Cookies and tracking technologies\n\n#### 3. How We Use Data\n- Provide platform services\n- Improve user experience\n- Security and fraud prevention\n- Communication and support\n- Legal compliance\n\n#### 4. Data Storage & Processing\n- Where data is stored (Switzerland)\n- How long data is retained\n- Data security measures\n- Encryption practices\n\n#### 5. Data Sharing\n- Third-party services (GitHub, Stripe)\n- Service providers\n- Legal requirements\n- No data selling policy\n\n#### 6. User Rights (GDPR)\n- Right to access\n- Right to rectification\n- Right to erasure (\"right to be forgotten\")\n- Right to data portability\n- Right to object\n- Right to restrict processing\n- How to exercise these rights\n\n#### 7. Cookies & Tracking\n- Types of cookies used\n- Cookie purposes\n- How to control cookies\n- Third-party analytics\n\n#### 8. Children's Privacy\n- Age restrictions\n- Parental consent requirements\n\n#### 9. International Data Transfers\n- EU-US data transfers\n- Adequacy decisions\n- Safeguards in place\n\n#### 10. Changes to Privacy Policy\n- How users will be notified\n- Effective date\n- Version history\n\n#### 11. Contact & Complaints\n- How to contact us\n- Data protection officer (if applicable)\n- Right to lodge complaint with supervisory authority\n\n**Acceptance Criteria:**\n\n- [ ] Draft privacy policy with legal team/consultant\n- [ ] Ensure GDPR compliance\n- [ ] Ensure DSGVO compliance\n- [ ] Include Swiss data protection law requirements\n- [ ] Add clear, user-friendly language\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Design privacy policy page\n- [ ] Add link in footer and signup flow\n- [ ] Implement consent management\n- [ ] Add cookie banner with preferences\n- [ ] Set up data export functionality\n- [ ] Implement data deletion process\n- [ ] Create process for handling data requests\n- [ ] Set up versioning and change notifications\n- [ ] Legal review and approval\n- [ ] Publish and announce to users",
    "state": "OPEN",
    "synced": true,
    "number": 235,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/235"
  },
  {
    "title": "[HIGH] Terms of Service",
    "labels": [
      "P1",
      "legal",
      "compliance",
      "documentation"
    ],
    "body": "Create comprehensive Terms of Service for the Helvetia Cloud platform to define the legal relationship with users and protect the business.\n\n**Current State:**\n- No terms of service\n- No legal agreement with users\n- Risk of liability and disputes\n\n**Requirements:**\n\n### Content to Include:\n\n#### 1. Introduction & Acceptance\n- Overview of services\n- Agreement to terms\n- Who can use the service\n- Changes to terms\n\n#### 2. Definitions\n- Service\n- User/Customer\n- Account\n- Content\n- Deployment\n\n#### 3. Account Registration\n- Account requirements\n- Account security\n- User responsibilities\n- Account termination\n\n#### 4. Service Description\n- Platform services offered\n- Service availability (SLA)\n- Service modifications\n- Beta features\n\n#### 5. Acceptable Use Policy\n- Permitted uses\n- Prohibited activities:\n  - Illegal content\n  - Malware/harmful code\n  - Resource abuse\n  - Cryptocurrency mining\n  - Spam/phishing\n  - DDoS attacks\n  - Copyright infringement\n- Enforcement and consequences\n\n#### 6. Content & Intellectual Property\n- User content ownership\n- License granted to Helvetia\n- Platform IP ownership\n- Copyright complaints (DMCA)\n- Trademark usage\n\n#### 7. Payment & Billing\n- Pricing and fees\n- Payment methods\n- Billing cycles\n- Refund policy\n- Late payment\n- Tax obligations\n\n#### 8. Service Limits & Quotas\n- Resource limits per plan\n- Fair use policy\n- Overage charges\n- Service throttling\n\n#### 9. Data & Privacy\n- Reference to Privacy Policy\n- Data ownership\n- Data backups\n- Data retention\n- Data portability\n\n#### 10. Security\n- Our security measures\n- User security responsibilities\n- Incident reporting\n- Vulnerability disclosure\n\n#### 11. Service Level Agreement (SLA)\n- Uptime guarantee\n- Maintenance windows\n- Service credits\n- Exclusions\n\n#### 12. Liability & Warranties\n- Service provided \"as is\"\n- Disclaimer of warranties\n- Limitation of liability\n- Indemnification\n- Force majeure\n\n#### 13. Termination\n- User termination rights\n- Our termination rights\n- Effects of termination\n- Data retention after termination\n- Survival of terms\n\n#### 14. Dispute Resolution\n- Governing law (Swiss law)\n- Jurisdiction\n- Arbitration clause (optional)\n- Class action waiver (where applicable)\n\n#### 15. Miscellaneous\n- Entire agreement\n- Severability\n- Waiver\n- Assignment\n- Third-party services\n- Contact information\n\n**Special Considerations:**\n\n- Swiss law compliance\n- EU law compliance (for EU users)\n- B2B vs B2C differences\n- Enterprise terms (if applicable)\n- Developer terms for API usage\n\n**Acceptance Criteria:**\n\n- [ ] Draft terms of service with legal team/consultant\n- [ ] Ensure compliance with Swiss law\n- [ ] Add EU-specific terms for EU users\n- [ ] Include acceptable use policy\n- [ ] Define clear SLA commitments\n- [ ] Add liability limitations\n- [ ] Include dispute resolution mechanism\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Design terms of service page\n- [ ] Add link in footer and signup flow\n- [ ] Require acceptance during signup\n- [ ] Implement terms version tracking\n- [ ] Set up notification for changes\n- [ ] Create separate enterprise terms (optional)\n- [ ] Legal review and approval\n- [ ] Publish and announce to users\n- [ ] Get existing user acceptance",
    "state": "OPEN",
    "synced": true,
    "number": 236,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/236"
  },
  {
    "title": "[MEDIUM] Frequently Asked Questions (FAQ)",
    "labels": [
      "P2",
      "documentation",
      "user-experience",
      "enhancement"
    ],
    "body": "Create a comprehensive FAQ page to answer common user questions and reduce support burden.\n\n**Current State:**\n- No FAQ page\n- Common questions answered repeatedly in support\n- No self-service help resource\n\n**FAQ Categories:**\n\n### General\n- What is Helvetia Cloud?\n- How does Helvetia Cloud work?\n- What can I deploy on Helvetia Cloud?\n- Where is my data hosted?\n- Is Helvetia Cloud secure?\n- How is Helvetia Cloud different from competitors?\n\n### Getting Started\n- How do I create an account?\n- How do I deploy my first application?\n- What programming languages are supported?\n- Do I need Docker knowledge?\n- Can I deploy existing Docker images?\n\n### Pricing & Billing\n- How much does Helvetia Cloud cost?\n- What's included in the free tier?\n- How is usage calculated?\n- When will I be charged?\n- Can I change my plan?\n- What payment methods are accepted?\n- How do I get a refund?\n- What happens if my payment fails?\n\n### Services & Deployments\n- How do I deploy a service?\n- What is a preview environment?\n- How do I set up auto-deployments?\n- How do I rollback a deployment?\n- Can I deploy databases?\n- How do I connect to my database?\n- What are the resource limits?\n- Can I scale my services?\n\n### Domains & SSL\n- How do I add a custom domain?\n- Is SSL/HTTPS automatic?\n- How long does domain setup take?\n- Can I use wildcard domains?\n- Do I need to purchase a domain?\n\n### Environment Variables\n- How do I set environment variables?\n- Are environment variables encrypted?\n- Can I use .env files?\n- How do I update environment variables?\n\n### Logs & Monitoring\n- How do I view logs?\n- How long are logs retained?\n- Can I export logs?\n- What metrics are available?\n- How do I set up alerts?\n\n### GitHub Integration\n- How does GitHub integration work?\n- Which repositories can I deploy?\n- Do I need webhook access?\n- Can I use private repositories?\n- Can I deploy from GitLab/Bitbucket?\n\n### Security & Compliance\n- Is my data secure?\n- How is data encrypted?\n- Are you GDPR compliant?\n- Where are backups stored?\n- Do you have a bug bounty program?\n- How do I report security issues?\n\n### Organizations & Teams\n- How do I create an organization?\n- How do I invite team members?\n- What are the different roles?\n- Can I transfer services between accounts?\n- How do I manage permissions?\n\n### Technical\n- What Docker versions are supported?\n- Can I use Docker Compose?\n- What ports can I expose?\n- How do I debug build failures?\n- Can I SSH into containers?\n- How do I run database migrations?\n- Can I use cron jobs?\n\n### Support & Help\n- How do I get help?\n- Do you offer phone support?\n- What's your response time?\n- Do you have a status page?\n- How do I report a bug?\n- Can I request features?\n\n### Account Management\n- How do I change my email?\n- How do I reset my password?\n- Can I delete my account?\n- What happens to my data after deletion?\n- How do I export my data?\n\n**Features:**\n\n- Search functionality\n- Category filtering\n- Related questions\n- \"Was this helpful?\" feedback\n- Link to support if not resolved\n- Multi-language support\n- Regular updates based on support tickets\n\n**Acceptance Criteria:**\n\n- [ ] Compile list of common questions from support tickets\n- [ ] Organize questions into logical categories\n- [ ] Write clear, concise answers\n- [ ] Add code examples where relevant\n- [ ] Include screenshots and diagrams\n- [ ] Create searchable FAQ page\n- [ ] Implement category filtering\n- [ ] Add related questions linking\n- [ ] Implement feedback mechanism\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Make FAQ easily accessible from navigation\n- [ ] Set up analytics to track popular questions\n- [ ] Establish process for updating FAQ regularly\n- [ ] Link FAQ entries in support responses\n- [ ] Add FAQ schema markup for SEO",
    "state": "OPEN",
    "synced": true,
    "number": 237,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/237"
  },
  {
    "title": "[MEDIUM] Platform Blog",
    "labels": [
      "P2",
      "marketing",
      "content",
      "enhancement"
    ],
    "body": "Create a blog for the Helvetia Cloud platform to share updates, tutorials, technical insights, and build community.\n\n**Current State:**\n- No blog or content marketing\n- Updates shared only through release notes\n- No technical content or thought leadership\n\n**Blog Purpose:**\n\n- Platform updates and announcements\n- Technical tutorials and how-tos\n- Industry insights and thought leadership\n- Customer success stories\n- Community highlights\n- SEO and inbound marketing\n\n**Content Categories:**\n\n### Announcements\n- New features and updates\n- Product roadmap\n- Platform milestones\n- Partnerships and integrations\n- Event participation\n\n### Tutorials\n- Deploy guides (Node.js, Python, Go, etc.)\n- Framework-specific tutorials (Next.js, Django, etc.)\n- Database setup guides\n- CI/CD integration\n- Performance optimization\n- Security best practices\n\n### Technical Deep Dives\n- Platform architecture\n- How we built X feature\n- Scaling strategies\n- Infrastructure decisions\n- Open source contributions\n\n### Use Cases\n- Customer success stories\n- Industry-specific solutions\n- Migration guides (from other platforms)\n- Cost comparison analyses\n\n### Company\n- Team updates\n- Company culture\n- Behind the scenes\n- Career opportunities\n\n**Technical Implementation:**\n\n### Technology Options:\n- **Next.js + MDX**: Full control, dynamic, SEO-friendly\n- **Ghost**: Powerful, dedicated blogging platform\n- **Strapi**: Headless CMS with flexibility\n- **WordPress**: Established, extensive plugins\n\n### Features Required:\n- Rich text editor\n- Code syntax highlighting\n- Image optimization\n- Categories and tags\n- Author profiles\n- Comments (optional)\n- Social sharing\n- RSS feed\n- Newsletter subscription\n- Search functionality\n- Related posts\n- Reading time estimates\n- Table of contents\n- Multi-language support\n\n### SEO Requirements:\n- Meta tags and descriptions\n- Open Graph images\n- Structured data (Article schema)\n- XML sitemap\n- Internal linking\n- Fast page loads\n- Mobile responsive\n\n**Content Strategy:**\n\n### Publishing Schedule:\n- 1-2 technical tutorials per month\n- 1 platform update per month\n- 1 thought leadership piece per quarter\n- Customer stories as available\n\n### Content Guidelines:\n- Clear, accessible writing\n- Code examples and demos\n- Visual aids (screenshots, diagrams)\n- Actionable takeaways\n- SEO optimization\n- Multi-language versions for key posts\n\n**Initial Content:**\n\n1. Welcome to Helvetia Cloud Blog\n2. Why We Built Helvetia Cloud\n3. Getting Started: Deploy Your First App\n4. Understanding Preview Environments\n5. Zero-Downtime Deployments Explained\n6. Database-as-a-Service Deep Dive\n7. Security Best Practices for Cloud Deployments\n8. Comparing Helvetia Cloud to Heroku/Railway/Render\n9. How to Migrate from Heroku to Helvetia Cloud\n10. Behind the Scenes: Our Infrastructure\n\n**Acceptance Criteria:**\n\n- [ ] Choose blogging platform/technology\n- [ ] Design blog layout matching platform branding\n- [ ] Set up blog infrastructure\n- [ ] Create content management workflow\n- [ ] Write and publish 5 initial blog posts\n- [ ] Implement SEO optimization\n- [ ] Add social sharing functionality\n- [ ] Set up newsletter integration\n- [ ] Create RSS feed\n- [ ] Add search functionality\n- [ ] Implement multi-language support\n- [ ] Set up analytics tracking\n- [ ] Create author profiles\n- [ ] Add related posts feature\n- [ ] Set up commenting system (optional)\n- [ ] Create content calendar\n- [ ] Establish editorial workflow\n- [ ] Promote blog in platform and marketing channels",
    "state": "OPEN",
    "synced": true,
    "number": 238,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/238"
  }
]