[
  {
    "title": "[CRITICAL] Hardcoded Cryptographic Salt in Encryption",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "The encryption module uses a hardcoded salt value `'salt'` for key derivation, which completely defeats the purpose of encryption and makes GitHub access tokens vulnerable to decryption.\n\n**Location:**\n`apps/api/src/utils/crypto.ts:8`\n\n**Current Code:**\n\n```typescript\nconst ENCRYPTION_KEY = crypto.scryptSync(KEY, 'salt', 32);\n```\n\n**Security Impact:**\n\n- GitHub access tokens are vulnerable to rainbow table attacks\n- If database is compromised, tokens can be easily decrypted\n- Violates cryptographic best practices\n\n**Recommended Fix:**\n\n```typescript\nconst SALT = process.env.ENCRYPTION_SALT || crypto.randomBytes(32).toString('hex');\nconst ENCRYPTION_KEY = crypto.scryptSync(KEY, SALT, 32);\n```\n\n**Better Solution:**\nUse a proper key management service (AWS KMS, HashiCorp Vault) or at minimum, store a secure random salt in environment variables.\n\n**Acceptance Criteria:**\n\n- [ ] Remove hardcoded salt\n- [ ] Generate unique salt per installation\n- [ ] Store salt securely in environment variables\n- [ ] Update .env.example with ENCRYPTION_SALT\n- [ ] Document migration path for existing encrypted data\n- [ ] Add tests for encryption/decryption",
    "number": 56,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/56",
    "synced": true,
    "contentHash": "c23915abbdcf2a959a616876e0cc1e8b2269f4c338656409af066877ad4b6f0d"
  },
  {
    "title": "[CRITICAL] Missing Rate Limiting Implementation",
    "labels": [
      "P0",
      "security",
      "critical",
      "enhancement"
    ],
    "body": "Despite having rate limiting configuration in environment variables, no rate limiting is actually implemented. Critical endpoints are vulnerable to brute-force and DoS attacks.\n\n**Vulnerable Endpoints:**\n\n- `/auth/github` - OAuth callback (brute force risk)\n- `/services/:id/deploy` - Resource-intensive operations (DoS risk)\n- `/webhooks/github` - External webhook (abuse risk)\n- All authenticated endpoints\n\n**Impact:**\n\n- Brute-force attacks on authentication\n- DoS through excessive deployment requests\n- Webhook spam overwhelming the system\n- Resource exhaustion\n\n**Recommended Implementation:**\n\n```typescript\nimport rateLimit from '@fastify/rate-limit';\n\n// Global rate limiting\nfastify.register(rateLimit, {\n  max: parseInt(process.env.RATE_LIMIT_MAX || '100'),\n  timeWindow: process.env.RATE_LIMIT_WINDOW || '1 minute',\n  redis: redisConnection,\n  keyGenerator: (request) => request.ip,\n});\n\n// Stricter limit for auth routes\nfastify.register(\n  rateLimit,\n  {\n    max: parseInt(process.env.AUTH_RATE_LIMIT_MAX || '10'),\n    timeWindow: process.env.AUTH_RATE_LIMIT_WINDOW || '1 minute',\n    redis: redisConnection,\n  },\n  { prefix: '/auth' },\n);\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install @fastify/rate-limit dependency\n- [ ] Implement global rate limiting\n- [ ] Implement stricter limits for authentication endpoints\n- [ ] Implement limits for deployment endpoints\n- [ ] Implement limits for WebSocket/SSE connections\n- [ ] Exclude /health endpoint from rate limiting\n- [ ] Add rate limit headers in responses\n- [ ] Add tests for rate limiting\n- [ ] Document rate limits in API docs",
    "number": 58,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/58",
    "synced": true,
    "contentHash": "b6744dce63be4552e06f42aa105cefe19eea061b194506426d3c484c70707c6e"
  },
  {
    "title": "[CRITICAL] GitHub Webhook Authentication Missing",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "GitHub webhooks endpoint (`/webhooks/github`) processes requests without verifying the signature. Anyone can trigger deployments by sending POST requests to this endpoint.\n\n**Location:**\n`apps/api/src/server.ts:979-1152`\n\n**Current Code:**\n\n```typescript\nfastify.post('/webhooks/github', async (request) => {\n  const payload = request.body as any;\n  // No signature verification!\n```\n\n**Security Impact:**\n\n- Unauthorized deployments can be triggered\n- Malicious actors can cause resource exhaustion\n- Preview environments can be created/destroyed without authorization\n- Potential for code injection through malicious payloads\n\n**Recommended Fix:**\n\n```typescript\nimport crypto from 'crypto';\n\nfunction verifyGitHubSignature(payload: string, signature: string, secret: string): boolean {\n  const hmac = crypto.createHmac('sha256', secret);\n  const digest = 'sha256=' + hmac.update(payload).digest('hex');\n  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));\n}\n\nfastify.post('/webhooks/github', async (request, reply) => {\n  const signature = request.headers['x-hub-signature-256'] as string;\n\n  if (!signature) {\n    return reply.status(401).send({ error: 'Missing signature' });\n  }\n\n  const rawBody = JSON.stringify(request.body);\n\n  if (!verifyGitHubSignature(rawBody, signature, process.env.GITHUB_WEBHOOK_SECRET!)) {\n    return reply.status(401).send({ error: 'Invalid signature' });\n  }\n\n  // ... process webhook\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add GITHUB_WEBHOOK_SECRET to environment variables\n- [ ] Implement signature verification function\n- [ ] Add signature verification to webhook endpoint\n- [ ] Return 401 for missing or invalid signatures\n- [ ] Log suspicious requests\n- [ ] Add tests for signature verification\n- [ ] Update documentation with webhook setup instructions\n- [ ] Update .env.example",
    "number": 59,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/59",
    "synced": true,
    "contentHash": "ed47b63d31ecba46eaa877a5280e8b24bf0393641fbc0e77838856f0128c61dc"
  },
  {
    "title": "[CRITICAL] Insecure CORS Configuration Allows Origin Reflection",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "SSE endpoints reflect the request origin back in `Access-Control-Allow-Origin` header with credentials enabled, effectively bypassing CORS protection.\n\n**Locations:**\n\n- `apps/api/src/server.ts:654-661` (metrics stream)\n- `apps/api/src/server.ts:1199-1206` (logs stream)\n\n**Vulnerable Code:**\n\n```typescript\n'Access-Control-Allow-Origin': request.headers.origin || '*',\n'Access-Control-Allow-Credentials': 'true',\n```\n\n**Security Impact:**\n\n- Cross-origin attacks possible\n- Session hijacking risk\n- CSRF vulnerabilities\n- Sensitive data exposure to malicious origins\n\n**Recommended Fix:**\n\n```typescript\nconst allowedOrigins = (\n  process.env.ALLOWED_ORIGINS ||\n  process.env.APP_BASE_URL ||\n  'http://localhost:3000'\n)\n  .split(',')\n  .map((o) => o.trim());\n\nfastify.register(cors, {\n  origin: (origin, cb) => {\n    if (!origin || allowedOrigins.includes(origin)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Not allowed by CORS'), false);\n    }\n  },\n  credentials: true,\n  methods: ['GET', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],\n});\n\n// For SSE endpoints\nreply.raw.writeHead(200, {\n  'Content-Type': 'text/event-stream',\n  'Cache-Control': 'no-cache',\n  Connection: 'keep-alive',\n  'X-Accel-Buffering': 'no',\n  'Access-Control-Allow-Origin': allowedOrigins.includes(request.headers.origin || '')\n    ? request.headers.origin\n    : allowedOrigins[0],\n  'Access-Control-Allow-Credentials': 'true',\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add ALLOWED_ORIGINS environment variable\n- [ ] Implement strict origin validation\n- [ ] Fix CORS configuration in server setup\n- [ ] Fix CORS headers in SSE endpoints\n- [ ] Remove wildcard origin fallback\n- [ ] Add tests for CORS validation\n- [ ] Document CORS configuration\n- [ ] Update .env.example",
    "number": 60,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/60",
    "synced": true,
    "contentHash": "46b9be17707a7ec223401820228170a7ea6b8fd2084d6e5edebfbe10bdf8062c"
  },
  {
    "title": "[CRITICAL] Host Filesystem Exposure via Docker Volume Mount",
    "labels": [
      "P0",
      "security",
      "critical",
      "bug"
    ],
    "body": "Worker mounts the entire `/Users` directory into builder containers, exposing all user data on macOS. This is extremely dangerous.\n\n**Location:**\n`apps/worker/src/worker.ts:104, 216`\n\n**Vulnerable Code:**\n\n```typescript\nBinds: ['/var/run/docker.sock:/var/run/docker.sock', '/Users:/Users'],\n```\n\n**Security Impact:**\n\n- Container can access all user data on macOS\n- Host filesystem can be modified by container\n- Privilege escalation possible\n- Violates principle of least privilege\n- Data breach risk\n\n**Recommended Fix:**\n\n```typescript\n// Only mount specific workspace directory, read-only\nconst workDir = process.env.WORKSPACE_DIR || '/tmp/helvetia-workspaces';\n\n// Ensure directory exists\nawait fs.promises.mkdir(workDir, { recursive: true });\n\nBinds: [\n  '/var/run/docker.sock:/var/run/docker.sock',\n  `${workDir}:/workspaces:ro`, // Read-only mount\n],\n```\n\n**Additional Security:**\n\n- Use temporary directories that are cleaned up\n- Never mount root directories\n- Use SELinux/AppArmor labels\n- Consider using Docker volumes instead of bind mounts\n\n**Acceptance Criteria:**\n\n- [ ] Remove /Users mount completely\n- [ ] Create dedicated workspace directory\n- [ ] Mount workspace as read-only\n- [ ] Add WORKSPACE_DIR environment variable\n- [ ] Implement workspace cleanup\n- [ ] Add documentation warning about production usage\n- [ ] Add tests to verify mount configuration\n- [ ] Update .env.example",
    "number": 61,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/61",
    "synced": true,
    "contentHash": "fcbaa565c2b94f03c5a822ca5e98ec78dc9763d4a31d88ae57cce011f4c56978"
  },
  {
    "title": "[HIGH] SQL Injection Risk with Prisma String Operations",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "Using `contains` with unsanitized user input in Prisma queries could be vulnerable to SQL injection or at minimum, unexpected behavior.\n\n**Location:**\nMultiple locations in `apps/api/src/server.ts`\n\n**Example:**\n\n```typescript\nwhere: {\n  repoUrl: {\n    contains: repoUrl;\n  }\n}\n```\n\n**Recommended Fix:**\n\n```typescript\nconst sanitizedRepoUrl = repoUrl.trim().replace(/\\.git$/, '');\nwhere: {\n  OR: [{ repoUrl: sanitizedRepoUrl }, { repoUrl: `${sanitizedRepoUrl}.git` }];\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Audit all Prisma queries using user input\n- [ ] Sanitize repo URLs before querying\n- [ ] Use exact matches where possible\n- [ ] Add input validation tests\n- [ ] Document safe query patterns",
    "number": 66,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/66",
    "synced": true,
    "contentHash": "5ddb15a1a3de37a3141e201703b879d699b3acfc977a5d59d926c62b664ba0e5"
  },
  {
    "title": "[HIGH] Missing Comprehensive Input Validation",
    "labels": [
      "P1",
      "security",
      "enhancement"
    ],
    "body": "Service creation and update endpoints lack comprehensive input validation, allowing potentially malicious or malformed data.\n\n**Location:**\n`apps/api/src/server.ts:500-597`\n\n**Missing Validations:**\n\n- Service name format (could contain special characters)\n- URL validation for repoUrl\n- Command injection prevention for buildCommand/startCommand\n- Size limits for envVars\n- Branch name validation\n\n**Recommended Implementation:**\nUse Zod for schema validation:\n\n```typescript\nimport { z } from 'zod';\n\nconst ServiceCreateSchema = z.object({\n  name: z\n    .string()\n    .min(3)\n    .max(63)\n    .regex(/^[a-z0-9-]+$/),\n  repoUrl: z.url().optional(),\n  branch: z\n    .string()\n    .min(1)\n    .max(255)\n    .regex(/^[a-zA-Z0-9-_./]+$/),\n  buildCommand: z.string().max(1000).optional(),\n  startCommand: z.string().max(1000).optional(),\n  port: z.number().int().min(1).max(65535),\n  envVars: z.record(z.string()).optional(),\n  customDomain: z.string().max(255).optional(),\n  type: z.enum(['DOCKER', 'STATIC', 'POSTGRES', 'REDIS', 'MYSQL', 'COMPOSE']),\n  staticOutputDir: z.string().max(255).optional(),\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install zod dependency\n- [ ] Create validation schemas for all endpoints\n- [ ] Implement request validation middleware\n- [ ] Return detailed validation errors\n- [ ] Add tests for validation\n- [ ] Document API request/response schemas",
    "number": 67,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/67",
    "synced": true,
    "contentHash": "89e0b3141752d3a972b816959375f23cf39fcf4cc85c607e072a0d5bbbe6abe7"
  },
  {
    "title": "[HIGH] SSE Connection Token Expiration Not Handled",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "Long-lived SSE connections don't re-validate JWT tokens, potentially allowing access after token expiration.\n\n**Locations:**\n\n- `apps/api/src/server.ts:650-705` (metrics)\n- `apps/api/src/server.ts:1184-1230` (logs)\n\n**Recommended Fix:**\nImplement periodic token validation in SSE streams.\n\n**Acceptance Criteria:**\n\n- [ ] Add periodic token validation (every 5 minutes)\n- [ ] Close connection on token expiration\n- [ ] Implement graceful reconnection on client side\n- [ ] Add tests for token expiration handling\n- [ ] Document SSE connection lifecycle",
    "number": 68,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/68",
    "synced": true,
    "contentHash": "f7a7cddda1b521b296d4faffd4bf28be7087a413ed73327ef8a2ce3d8ad6ffa8"
  },
  {
    "title": "[HIGH] Incomplete Error Handling in Worker Deployment",
    "labels": [
      "P1",
      "bug",
      "reliability"
    ],
    "body": "Worker's catch block doesn't handle partial failures properly. Resources may not be cleaned up correctly on deployment failure.\n\n**Location:**\n`apps/worker/src/worker.ts:435-445`\n\n**Issues:**\n\n- Builder container might not be cleaned up\n- Old containers might not be restarted on rollback\n- No rollback mechanism for failed deployments\n\n**Acceptance Criteria:**\n\n- [ ] Implement comprehensive cleanup in catch block\n- [ ] Add rollback to previous container on failure\n- [ ] Ensure builder container always cleaned up\n- [ ] Log detailed error information\n- [ ] Add tests for failure scenarios\n- [ ] Update deployment status correctly on all paths",
    "number": 70,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/70",
    "synced": true,
    "contentHash": "824eff390c6627b84f226312431e0a51053fa938d7f7f1f9e9936da4da67365c"
  },
  {
    "title": "[HIGH] Race Condition in Service Status Updates",
    "labels": [
      "P1",
      "bug",
      "concurrency"
    ],
    "body": "Service status is updated from multiple places without synchronization, leading to race conditions and stale data.\n\n**Locations:**\n\n- API sets status to DEPLOYING when queuing\n- Worker sets status after deployment\n- Docker status checked asynchronously\n\n**Recommended Solution:**\nImplement Redis-based distributed locks using Redlock.\n\n**Acceptance Criteria:**\n\n- [ ] Install redlock dependency\n- [ ] Implement distributed locking for status updates\n- [ ] Create status reconciliation service\n- [ ] Add tests for concurrent updates\n- [ ] Document status lifecycle",
    "number": 71,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/71",
    "synced": true,
    "contentHash": "8d03511561a34e173524ccb0d1db90d377423279e66714bd5ad77105b34115bf"
  },
  {
    "title": "[HIGH] Docker Socket Security Risk",
    "labels": [
      "P1",
      "security",
      "architecture"
    ],
    "body": "Direct Docker socket access in both API and Worker provides root-level access to host system.\n\n**Impact:**\n\n- Container escape vulnerabilities\n- Host system compromise potential\n- Privilege escalation risks\n\n**Recommended Solutions:**\n\n1. Run Docker daemon in rootless mode\n2. Implement Docker socket proxy with ACLs\n3. Consider migrating to Kubernetes\n\n**Acceptance Criteria:**\n\n- [ ] Document security implications\n- [ ] Implement Docker socket proxy\n- [ ] Add SELinux/AppArmor policies\n- [ ] Create security hardening guide\n- [ ] Consider Kubernetes migration path",
    "number": 72,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/72",
    "synced": true,
    "contentHash": "8e111b9faa91d1befc539af0f14ca3a416b25215e7fb79d00e21e36bf6625ade"
  },
  {
    "title": "[HIGH] Memory Leak Risk in SSE Connections",
    "labels": [
      "P1",
      "bug",
      "performance"
    ],
    "body": "SSE connection intervals may not be properly cleaned up on errors, leading to memory leaks.\n\n**Location:**\n`apps/api/src/server.ts:650-705`\n\n**Recommended Fix:**\nAdd comprehensive error handling and cleanup.\n\n**Acceptance Criteria:**\n\n- [ ] Add error handling in interval callbacks\n- [ ] Ensure cleanup on all error paths\n- [ ] Add connection state tracking\n- [ ] Implement connection timeout\n- [ ] Add tests for error scenarios\n- [ ] Monitor memory usage",
    "number": 73,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/73",
    "synced": true,
    "contentHash": "1060856c8ec516e9009ae4a9e22e0ec9a41a5e1a747ce00c5c8c0fa1dda0c46b"
  },
  {
    "title": "[HIGH] Unrestricted Service Deletion Risk",
    "labels": [
      "P1",
      "bug",
      "data-loss"
    ],
    "body": "Service deletion is permanent and irreversible without safety mechanisms.\n\n**Recommended Implementation:**\nImplement soft deletion with retention period.\n\n**Acceptance Criteria:**\n\n- [ ] Add deletedAt field to Service model\n- [ ] Implement soft deletion\n- [ ] Add delete protection flag\n- [ ] Schedule cleanup after retention period\n- [ ] Add recovery mechanism\n- [ ] Require re-authentication for deletion\n- [ ] Add tests for deletion flow",
    "number": 74,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/74",
    "synced": true,
    "contentHash": "bbc39193bd6a5b926d1691cc11d8537311fa078662322f10891ce58912f709ea"
  },
  {
    "title": "[MEDIUM] Missing Dockerfile Generation Validation",
    "labels": [
      "P2",
      "enhancement",
      "reliability"
    ],
    "body": "Generated Dockerfiles aren't validated before build, leading to hard-to-debug failures.\n\n**Location:**\n`apps/worker/src/worker.ts:225-310`\n\n**Acceptance Criteria:**\n\n- [ ] Add Dockerfile syntax validation\n- [ ] Implement dry-run before build\n- [ ] Validate environment variable format\n- [ ] Add better error messages\n- [ ] Add tests for various scenarios",
    "number": 75,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/75",
    "synced": true,
    "contentHash": "65b1cf775911151fb3dea22cba3d591a8c1206405e75b685e6ba94af26a6c9ed"
  },
  {
    "title": "[MEDIUM] Hardcoded Magic Numbers Throughout Codebase",
    "labels": [
      "P2",
      "refactoring",
      "maintainability"
    ],
    "body": "Magic numbers scattered throughout code reduce maintainability.\n\n**Examples:**\n\n- `512 * 1024 * 1024` (Memory limit)\n- `1000000000` (CPU limit)\n- `5000` (Metrics interval)\n\n**Acceptance Criteria:**\n\n- [ ] Create constants configuration file\n- [ ] Extract all magic numbers\n- [ ] Make limits configurable via env vars\n- [ ] Update documentation\n- [ ] Add tests with different configurations",
    "number": 76,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/76",
    "synced": true,
    "contentHash": "604a53881cee0e840a4de07bdd8f46e2d05cd6cdf7655fdfd20afed4aeed29a4"
  },
  {
    "title": "[MEDIUM] Missing Request/Response Logging",
    "labels": [
      "P2",
      "observability",
      "enhancement"
    ],
    "body": "No structured logging for requests and responses, making debugging difficult.\n\n**Acceptance Criteria:**\n\n- [ ] Implement request logging hook\n- [ ] Implement response logging hook\n- [ ] Add structured logging with context\n- [ ] Configure log levels per environment\n- [ ] Add request ID correlation\n- [ ] Document logging format",
    "number": 77,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/77",
    "synced": true,
    "contentHash": "db039597ab911982642edee9d4c1cf1237a3b3926072f20e5f9e10bfa6ed1f86"
  },
  {
    "title": "[MEDIUM] No Health Check Endpoint for Worker",
    "labels": [
      "P2",
      "observability",
      "enhancement"
    ],
    "body": "Worker service lacks health check endpoint for monitoring.\n\n**Acceptance Criteria:**\n\n- [ ] Add HTTP health endpoint\n- [ ] Include queue stats\n- [ ] Include Redis connection status\n- [ ] Include uptime information\n- [ ] Document health check format\n- [ ] Add monitoring setup guide",
    "number": 78,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/78",
    "synced": true,
    "contentHash": "d173a60e36e6f6eabaef699c21f91c6facab8801a330672dc53f57d540701d41"
  },
  {
    "title": "[MEDIUM] Incomplete Test Coverage",
    "labels": [
      "P2",
      "testing",
      "quality"
    ],
    "body": "Test suite exists but critical paths aren't fully covered.\n\n**Missing Tests:**\n\n- Integration tests for deployment flow\n- Webhook processing tests\n- SSE streaming tests\n- Worker deployment tests (currently failing)\n\n**Acceptance Criteria:**\n\n- [ ] Fix failing worker tests\n- [ ] Add integration tests\n- [ ] Achieve 80% code coverage minimum\n- [ ] Add E2E tests for critical flows\n- [ ] Set up test containers for integration tests\n- [ ] Add coverage reporting to CI",
    "number": 79,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/79",
    "synced": true,
    "contentHash": "b81a8cc1a776c350c2f549aa970abfa9c4d7f0ffee18c747a8c37526986438bf"
  },
  {
    "title": "[MEDIUM] Environment Variable Management Needs Improvement",
    "labels": [
      "P2",
      "enhancement",
      "configuration"
    ],
    "body": "No validation for required environment variables, leading to potential runtime errors.\n\n**Acceptance Criteria:**\n\n- [ ] Install zod for validation\n- [ ] Create environment schema\n- [ ] Validate on startup\n- [ ] Provide clear error messages\n- [ ] Add type safety for env vars\n- [ ] Update documentation",
    "number": 80,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/80",
    "synced": true,
    "contentHash": "af06bdf035067e50112bcbea558964ec4252ae9f996f444b011872f40401be32"
  },
  {
    "title": "[MEDIUM] No Database Migration Strategy",
    "labels": [
      "P2",
      "database",
      "deployment"
    ],
    "body": "Using `db:push` instead of migrations is dangerous for production.\n\n**Issues:**\n\n- No migration history\n- Can cause data loss\n- Can't rollback changes\n- No team collaboration on schema changes\n\n**Acceptance Criteria:**\n\n- [ ] Switch to Prisma Migrate\n- [ ] Create initial migration\n- [ ] Update deployment scripts\n- [ ] Document migration workflow\n- [ ] Add rollback procedures\n- [ ] Update CI/CD pipeline",
    "number": 81,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/81",
    "synced": true,
    "contentHash": "e1c0268e5bc23dc2a32326ec615d86f18a855fc9f1dbd6e480f46e9824ef6892"
  },
  {
    "title": "[MEDIUM] Frontend State Management Issues",
    "labels": [
      "P2",
      "frontend",
      "performance"
    ],
    "body": "Dashboard has performance issues and state management anti-patterns.\n\n**Issues:**\n\n- Services fetched on every re-render\n- No caching mechanism\n- Large component needs splitting\n- Optimistic updates without proper rollback\n\n**Acceptance Criteria:**\n\n- [ ] Install React Query or SWR\n- [ ] Implement data caching\n- [ ] Split large components\n- [ ] Add error boundaries\n- [ ] Implement proper loading states\n- [ ] Add tests for state management",
    "number": 82,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/82",
    "synced": true,
    "contentHash": "50e8821df44ab84884eb1ca0ec5dff4b381268cf4230534e3d505d895f462454"
  },
  {
    "title": "[MEDIUM] Docker Image Cleanup Missing",
    "labels": [
      "P2",
      "infrastructure",
      "resource-management"
    ],
    "body": "No cleanup for dangling, failed, or old Docker images, leading to disk space issues.\n\n**Acceptance Criteria:**\n\n- [ ] Implement periodic cleanup job\n- [ ] Remove dangling images\n- [ ] Remove old image versions\n- [ ] Add retention policy\n- [ ] Monitor disk usage\n- [ ] Add configuration options",
    "number": 83,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/83",
    "synced": true,
    "contentHash": "ae1a3c0c125949b6441378e6935d55a62b7fb1d5bcf8b17db55df49066a146a6"
  },
  {
    "title": "[MEDIUM] Missing Prometheus Metrics",
    "labels": [
      "P2",
      "observability",
      "monitoring"
    ],
    "body": "No metrics exported for system monitoring.\n\n**Needed Metrics:**\n\n- Request rates and latencies\n- Error rates\n- Deployment success/failure rates\n- Queue depths\n- Resource usage\n\n**Acceptance Criteria:**\n\n- [ ] Install prom-client\n- [ ] Add /metrics endpoint\n- [ ] Implement custom metrics\n- [ ] Add Grafana dashboard\n- [ ] Document metrics\n- [ ] Set up alerting",
    "number": 84,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/84",
    "synced": true,
    "contentHash": "460d30925aff7d8b415525aca5c91241e5612bc961871705af142450afbec14a"
  },
  {
    "title": "[MEDIUM] Session Management Needs Refresh Tokens",
    "labels": [
      "P2",
      "security",
      "enhancement"
    ],
    "body": "JWT tokens have 7-day expiration with no refresh mechanism.\n\n**Acceptance Criteria:**\n\n- [ ] Implement refresh token flow\n- [ ] Use short-lived access tokens (15 min)\n- [ ] Implement token rotation\n- [ ] Add token revocation list in Redis\n- [ ] Update frontend to handle refresh\n- [ ] Add tests for token lifecycle",
    "number": 69,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/69",
    "synced": true,
    "contentHash": "48309b71285bd317026537bf1e10a2a7f299a6301a28baa33a75c07866295c09"
  },
  {
    "title": "[MEDIUM] No Request Size Limits",
    "labels": [
      "P2",
      "security",
      "performance"
    ],
    "body": "Missing request body size limits could allow DoS attacks.\n\n**Acceptance Criteria:**\n\n- [ ] Add body size limit to Fastify config\n- [ ] Configure appropriate limits (10MB default)\n- [ ] Add limits per endpoint type\n- [ ] Document size limits\n- [ ] Add tests for size validation\n- [ ] Return appropriate error messages",
    "number": 85,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/85",
    "synced": true,
    "contentHash": "f266384f9086939c8485381048cfd956bf59cea1fe5b60e53e48ac3c52d798bf"
  },
  {
    "title": "[LOW] Excessive TypeScript `any` Usage",
    "labels": [
      "P3",
      "refactoring",
      "type-safety"
    ],
    "body": "Extensive use of `any` type reduces type safety benefits.\n\n**Acceptance Criteria:**\n\n- [ ] Add Fastify type augmentation\n- [ ] Create proper request/response types\n- [ ] Remove `as any` casts\n- [ ] Enable stricter TypeScript checks\n- [ ] Document type patterns",
    "number": 93,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/93",
    "synced": true,
    "contentHash": "6540ec172df651fca4175ce60b0d5c3a6c6c7f00a8a259047378918236a1a2b9"
  },
  {
    "title": "[LOW] Inconsistent Error Messages",
    "labels": [
      "P3",
      "ux",
      "enhancement"
    ],
    "body": "Error messages aren't user-friendly or consistent.\n\n**Acceptance Criteria:**\n\n- [ ] Create error response standard\n- [ ] Add error codes\n- [ ] Make messages user-friendly\n- [ ] Add i18n support for errors\n- [ ] Document error codes\n- [ ] Update frontend error handling",
    "number": 87,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/87",
    "synced": true,
    "contentHash": "bc90a3fa109ab20d797453d4b58b14eb13b9b2b02175e610d809ddd9a2669069"
  },
  {
    "title": "[LOW] Missing API Versioning",
    "labels": [
      "P3",
      "api",
      "architecture"
    ],
    "body": "No API versioning strategy makes future changes risky.\n\n**Acceptance Criteria:**\n\n- [ ] Add version prefix (/api/v1)\n- [ ] Document versioning strategy\n- [ ] Plan v2 transition path\n- [ ] Update frontend API calls\n- [ ] Add version negotiation",
    "number": 88,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/88",
    "synced": true,
    "contentHash": "bbb4e4fe089fe0b5bd5e9bc64bf17a3f79ffaa8bde9c382dc57ed14352b339da"
  },
  {
    "title": "[LOW] No Request ID Tracing",
    "labels": [
      "P3",
      "observability",
      "enhancement"
    ],
    "body": "Missing correlation IDs makes request tracing difficult.\n\n**Acceptance Criteria:**\n\n- [ ] Add request ID generation\n- [ ] Propagate IDs across services\n- [ ] Include in all log entries\n- [ ] Return in response headers\n- [ ] Document tracing setup",
    "number": 89,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/89",
    "synced": true,
    "contentHash": "323dd72553054663a65c56ead368d62a51f4513be3fe08beca7f1c822f263725"
  },
  {
    "title": "[LOW] Lack of Feature Flags",
    "labels": [
      "P3",
      "deployment",
      "enhancement"
    ],
    "body": "No way to enable/disable features without deployment.\n\n**Acceptance Criteria:**\n\n- [ ] Choose feature flag service\n- [ ] Implement feature flag checks\n- [ ] Add admin UI for flags\n- [ ] Document feature flag usage\n- [ ] Add A/B testing capability",
    "number": 90,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/90",
    "synced": true,
    "contentHash": "ea2936094d312221457af24ad95cef1307d3d864fa82ee12b8bba589264802a2"
  },
  {
    "title": "[LOW] No Graceful Shutdown",
    "labels": [
      "P3",
      "reliability",
      "enhancement"
    ],
    "body": "Services don't handle SIGTERM/SIGINT gracefully.\n\n**Acceptance Criteria:**\n\n- [ ] Implement graceful shutdown\n- [ ] Wait for in-flight requests\n- [ ] Close connections properly\n- [ ] Update deployment docs\n- [ ] Add tests for shutdown",
    "number": 91,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/91",
    "synced": true,
    "contentHash": "cb724dae67ab0f3dbae73b7b4329b02df26d2001ffcdc510735638887e2f6574"
  },
  {
    "title": "[LOW] Dashboard Accessibility Issues",
    "labels": [
      "P3",
      "accessibility",
      "a11y",
      "frontend"
    ],
    "body": "Several accessibility improvements needed for WCAG compliance.\n\n**Issues:**\n\n- Missing ARIA labels\n- Insufficient color contrast\n- No keyboard navigation hints\n- Modal focus trap not complete\n\n**Acceptance Criteria:**\n\n- [ ] Run axe-core audit\n- [ ] Fix all critical a11y issues\n- [ ] Add ARIA labels\n- [ ] Improve color contrast\n- [ ] Implement proper focus management\n- [ ] Add keyboard navigation\n- [ ] Test with screen readers",
    "number": 92,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/92",
    "synced": true,
    "contentHash": "d3599dc35562255763451285f1608974e4e068272e3b7ad28b4fc8f576b2a722"
  },
  {
    "title": "[HIGH] Implement Dependency Injection & Core Interfaces",
    "labels": [
      "P1",
      "refactoring",
      "architecture"
    ],
    "body": "Introduce dependency injection to decouple components and enable testability.\n\n**Current Issue:**\n- Direct instantiation of Docker, Redis, Prisma throughout codebase\n- Cannot mock dependencies for testing\n- Cannot swap implementations\n\n**Tasks:**\n\n- [ ] Set up DI framework (TSyringe or InversifyJS)\n- [ ] Define core interface contracts (IServiceRepository, IDeploymentRepository, IUserRepository, IContainerOrchestrator, IDeploymentQueue, ILogger, ICache)\n- [ ] Create base error hierarchy (AppError, ValidationError, NotFoundError)\n- [ ] Set up DI container configuration\n\n**Note:** This issue defines interface contracts only. Implementations are handled by other issues (#95 for repositories, #97 for container orchestrator).\n\n**Benefits:**\n- Better testability\n- Loose coupling\n- Easier to swap implementations",
    "number": 125,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/125",
    "contentHash": "65529333c1f8763413500b61fee1fe2e4da0e5cd1fe708f797927489bc30c3c4"
  },
  {
    "title": "[HIGH] Extract Repository Pattern for Data Access",
    "labels": [
      "P1",
      "refactoring",
      "database"
    ],
    "body": "Implement repository pattern for data access using interfaces from #94.\n\n**Current Issue:**\n- Prisma queries scattered throughout route handlers\n- Business logic mixed with data access\n- Hard to test and maintain\n\n**Tasks:**\n\n- [ ] Implement Prisma-based repositories (ServiceRepository, DeploymentRepository, UserRepository) using interfaces from #94\n- [ ] Replace direct Prisma calls with repository methods\n- [ ] Add repository unit tests\n- [ ] Register repositories in DI container\n\n**Dependencies:** Requires #94 (interface definitions)\n\n**Benefits:**\n- Clean separation of data access\n- Easier to test business logic\n- Can swap database implementations",
    "number": 126,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/126",
    "contentHash": "b324664c68b4a02562ef89a88d9e25bada67c5d42e50946cfd29ca5edec18f76"
  },
  {
    "title": "[HIGH] Create Service Layer for Business Logic",
    "labels": [
      "P1",
      "refactoring",
      "architecture"
    ],
    "body": "Extract business logic from route handlers into dedicated service classes.\n\n**Current Issue:**\n- Business logic embedded in route handlers\n- No reusability across endpoints\n- Difficult to test in isolation\n\n**Tasks:**\n\n- [ ] Create application services (ServiceManagementService, DeploymentOrchestrator, AuthenticationService)\n- [ ] Extract business logic from route handlers into services\n- [ ] Define DTOs and validation schemas\n- [ ] Add comprehensive service tests\n- [ ] Register services in DI container\n\n**Note:** Complete this before #98 (route refactoring). #98 will then handle the remaining route/controller structure.\n\n**Dependencies:** Works best after #94 (DI setup) and #95 (repositories)\n\n**Benefits:**\n- Testable business logic\n- Reusable across different interfaces\n- Clear separation of concerns",
    "number": 127,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/127",
    "contentHash": "e793ad44d1bab532523cfee544f36c52daf95e2715b28a0e1b39ee514b894f07"
  },
  {
    "title": "[MEDIUM] Abstract Container Orchestration Logic",
    "labels": [
      "P2",
      "refactoring",
      "infrastructure"
    ],
    "body": "Implement container orchestration abstraction using interface from #94.\n\n**Current Issue:**\n- Container management duplicated in API and Worker\n- Direct Docker API calls throughout\n- Cannot easily test container logic\n\n**Tasks:**\n\n- [ ] Implement DockerContainerOrchestrator using IContainerOrchestrator interface from #94\n- [ ] Extract container utilities (VolumeManager, NetworkManager, HealthChecker)\n- [ ] Replace direct Docker calls with orchestrator\n- [ ] Add integration tests\n- [ ] Register orchestrator in DI container\n\n**Note:** Package migration to shared location is handled by #101.\n\n**Dependencies:** Requires #94 (interface definition). Can work in parallel with #95, #96, #98.\n\n**Benefits:**\n- DRY - single container implementation\n- Can work in parallel with route refactoring\n- Easier to test",
    "number": 128,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/128",
    "contentHash": "1af8e5c0028df9b90c157875536381b25b92c8b4bd2d47398fdce2205ded6d24"
  },
  {
    "title": "[MEDIUM] Refactor API Routes into Controllers",
    "labels": [
      "P2",
      "refactoring",
      "api"
    ],
    "body": "Split monolithic server.ts into focused controllers and route files after business logic extraction.\n\n**Current Issue:**\n- Single file handles all routes, auth, remaining logic\n- Hard to navigate and maintain\n- High risk of merge conflicts\n\n**Tasks:**\n\n- [ ] Create thin controller classes (ServiceController, DeploymentController, AuthController, WebhookController) that call services from #96\n- [ ] Extract route definitions to separate files\n- [ ] Implement middleware (auth, validation, error handling)\n- [ ] Refactor SSE/WebSocket handlers\n\n**Dependencies:** Should be done after #96 (service layer) to avoid refactoring business logic twice.\n\n**Benefits:**\n- Smaller, focused files\n- Reduced merge conflicts\n- Easier to navigate codebase",
    "number": 129,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/129",
    "contentHash": "a787900ecad7eb973316354ac06e1e036574cda4b5200bb5a61da9d432eec660"
  },
  {
    "title": "[MEDIUM] Implement Strategy Pattern for Deployment Types",
    "labels": [
      "P2",
      "refactoring",
      "worker"
    ],
    "body": "Use Strategy Pattern to handle different service deployment types.\n\n**Current Issue:**\n- Hardcoded if/else checks for service types\n- Adding new types requires modifying existing code\n- Violates Open/Closed Principle\n\n**Tasks:**\n\n- [ ] Create IDeploymentStrategy interface\n- [ ] Implement strategies (DockerDeploymentStrategy, StaticDeploymentStrategy, DatabaseDeploymentStrategy, ComposeDeploymentStrategy)\n- [ ] Update worker to use strategy pattern\n- [ ] Extract builders (DockerfileBuilder, ComposeFileBuilder)\n- [ ] Add strategy tests\n\n**Note:** Can work independently from API refactoring (#96, #98) since it focuses on worker.\n\n**Benefits:**\n- Easy to add new service types\n- Better code organization\n- Can work independently from API refactoring",
    "number": 130,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/130",
    "contentHash": "c7e1de0f070796a625cb599a2b6d6e5f1d3e16006411cefd403faa8524a231e3"
  },
  {
    "title": "[MEDIUM] Improve TypeScript Type Safety",
    "labels": [
      "P2",
      "refactoring",
      "type-safety",
      "duplicate"
    ],
    "body": "**Note:** This issue duplicates #93. Please use #93 for all TypeScript type safety improvements.\n\n**Closing Reason:** Issue #93 already tracks the same work:\n- Remove `any` types\n- Add Fastify type augmentation\n- Create proper request/response types\n- Remove `as any` casts\n- Enable stricter TypeScript checks\n\nTo avoid splitting work across multiple issues, all TypeScript type safety improvements are consolidated in #93.",
    "number": 131,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/131",
    "contentHash": "f1f055cf44b5c112299f3ff50d7bb43d364142a51e473e20aaf084c2bc913f36"
  },
  {
    "title": "[LOW] Create Shared Package for Common Logic",
    "labels": [
      "P3",
      "refactoring",
      "architecture"
    ],
    "body": "Extract duplicated logic into shared package used by API and Worker.\n\n**Current Issue:**\n- Container logic duplicated\n- Status determination repeated\n- Utilities not shared\n\n**Tasks:**\n\n- [ ] Create packages/shared structure\n- [ ] Move container orchestrator and utilities from #97 to shared package\n- [ ] Move status lock logic\n- [ ] Move log scrubber\n- [ ] Update imports in API and Worker\n- [ ] Update package.json dependencies\n\n**Note:** This handles the shared package migration for code from other refactoring issues (especially #97).\n\n**Dependencies:** Best done after #97 (container abstraction) is complete.\n\n**Benefits:**\n- DRY principle\n- Consistent behavior\n- Easier to maintain",
    "number": 132,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/132",
    "contentHash": "434b1ce0fac025d834c7f41f907a3dc0f81ac080d3f26a5651a1d61f0ff5cdfd"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Service Routes to ServiceController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate service-related routes from `server.ts` to `ServiceController` and `service.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `GET /services`\n- `POST /services` (creation)\n- `GET /services/:id`\n- `PATCH /services/:id`\n- `DELETE /services/:id`\n- `GET /services/:id/health`\n- `GET /services/:id/metrics`\n- `GET /services/metrics/stream` (SSE)\n\n**Tasks:**\n- [ ] Implement `ServiceController` using injected repositories and services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/service.routes.ts` and register it in `index.ts`\n- [ ] Ensure all middleware (auth, validation) is correctly applied\n- [ ] Add unit tests for `ServiceController`",
    "synced": true,
    "number": 146,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/146",
    "contentHash": "e81363eefad4f6b1cd004c47dd9b689cc6321d76fb55c79a0c6a4d7961458d45"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Deployment Routes to DeploymentController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate deployment-related routes from `server.ts` to `DeploymentController` and `deployment.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `POST /services/:id/deploy`\n- `POST /services/:id/restart`\n- `GET /services/:id/deployments`\n- `GET /deployments/:id/logs`\n- `GET /deployments/:id/logs/stream` (SSE)\n\n**Tasks:**\n- [ ] Implement `DeploymentController` using injected repositories and services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/deployment.routes.ts` and register it in `index.ts`\n- [ ] Ensure all middleware (auth, validation) is correctly applied\n- [ ] Add unit tests for `DeploymentController`",
    "synced": true,
    "number": 147,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/147",
    "contentHash": "c0d6e2889c47d2fcfc37e025ef9d7a39f901dc6d36832de694beb56ee6fabe0a"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate GitHub Proxy Routes to GitHubController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate GitHub proxy routes from `server.ts` to `GitHubController` and `github.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `GET /github/orgs`\n- `GET /github/repos`\n- `GET /github/repos/:owner/:name/branches`\n\n**Tasks:**\n- [ ] Implement `GitHubController` using injected services\n- [ ] Move route logic from `server.ts` to controller methods\n- [ ] Create `apps/api/src/routes/github.routes.ts` and register it in `index.ts`\n- [ ] Ensure GitHub API error handling is preserved\n- [ ] Add unit tests for `GitHubController`",
    "synced": true,
    "number": 148,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/148",
    "contentHash": "937f44df2759f9ee4cd1d823ab6a1b89d59af8be178db67fa77db4f4e514149b"
  },
  {
    "title": "[MEDIUM] Phase 4: Migrate Webhook Routes to WebhookController",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "di-migration"
    ],
    "body": "Migrate GitHub webhook routes from `server.ts` to `WebhookController` and `webhook.routes.ts` as part of Phase 4 of the DI migration.\n\n**Routes to migrate:**\n- `POST /webhooks/github`\n\n**Tasks:**\n- [ ] Implement `WebhookController` and move signature verification logic\n- [ ] Move PR and Push event handling logic to controller methods\n- [ ] Create `apps/api/src/routes/webhook.routes.ts` and register it in `index.ts`\n- [ ] Ensure raw body parsing for signature verification is correctly handled in the new structure\n- [ ] Add unit tests for `WebhookController`",
    "synced": true,
    "number": 149,
    "state": "CLOSED",
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/149",
    "contentHash": "4abd2d96b1a35ff40479cd76625fb928b3848b4f6f44e1e091e3c8b1cc68ea92"
  },
  {
    "title": "[MEDIUM] Standardize Zod Error Handling with z.treeifyError()",
    "labels": [
      "P2",
      "refactoring",
      "api",
      "dx"
    ],
    "body": "Currently, controllers manually map ZodError issues into a flat array. We should migrate all controllers to use `z.treeifyError()` (formerly `error.flatten()`) for consistent, structured error responses that match the request body shape.\n\n**Benefits:**\n- zero boilerplate in error handlers\n- structured nested errors for complex forms\n- easier for frontend to map errors to specific fields\n\n**Tasks:**\n- [ ] Update `ServiceController.ts` to use `z.treeifyError()`\n- [ ] Update `FeatureFlagController.ts` to use `z.treeifyError()`\n- [ ] Audit and update any other controllers using Zod validation\n- [ ] Update Dashboard error handling to support the tree-like structure",
    "number": 167,
    "state": "CLOSED",
    "synced": true,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/167",
    "contentHash": "7867658a246e18ff4912664ca589451e5d57ee79f688814f80c76322920292e7"
  },
  {
    "title": "[HIGH] Insecure Password Hashing Using SHA-256 Without Salt",
    "labels": [
      "P1",
      "security",
      "bug"
    ],
    "body": "The admin user password hashing uses SHA-256 without salt, which is cryptographically weak and vulnerable to rainbow table attacks.\n\n**Locations:**\n- `apps/api/src/services/InitializationService.ts:111-113`\n- `apps/api/src/services/AuthenticationService.ts:40`\n\n**Current Code:**\n\n```typescript\nprivate hashPassword(password: string): string {\n  // TODO: In a real production app, use bcrypt or argon2 with a proper salt\n  return crypto.createHash('sha256').update(password).digest('hex');\n}\n```\n\n**Security Impact:**\n\n- Passwords vulnerable to rainbow table attacks\n- No salt means identical passwords have identical hashes\n- SHA-256 is too fast for password hashing (allows brute-force attacks)\n- Violates OWASP password storage guidelines\n\n**Recommended Fix:**\n\n```typescript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;\n\nasync hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Install bcrypt or argon2 dependency\n- [ ] Implement proper password hashing with salt\n- [ ] Update InitializationService to use secure hashing\n- [ ] Update AuthenticationService to use secure verification\n- [ ] Create migration path for existing passwords\n- [ ] Add tests for password hashing\n- [ ] Document password requirements",
    "state": "CLOSED",
    "synced": true,
    "number": 183,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/183",
    "contentHash": "c4ebf5a78934c09a9f91f2b09e3fb6fbc42dde615b754e6c9106796646428089"
  },
  {
    "title": "[HIGH] Duplicate Docker Client Instantiation on Every Request",
    "labels": [
      "P1",
      "performance",
      "bug"
    ],
    "body": "Docker client is instantiated inside controller methods on every request, creating performance overhead and potential resource leaks.\n\n**Locations:**\n- `apps/api/src/controllers/ServiceController.ts:62-64, 102-104, 272-274, 386-387`\n- `apps/api/src/controllers/DeploymentController.ts:100-101, 225-226`\n\n**Current Code:**\n\n```typescript\nasync getAllServices(request: FastifyRequest) {\n  // ...\n  const Docker = (await import('dockerode')).default;\n  const docker = new Docker(); // Created on every request!\n  // ...\n}\n```\n\n**Performance Impact:**\n\n- Unnecessary dynamic imports on every request\n- Creates new Docker client connections repeatedly\n- Memory overhead from multiple client instances\n- Potential connection pool exhaustion\n\n**Recommended Fix:**\n\n```typescript\n// Inject Docker client via DI container\n@injectable()\nexport class ServiceController {\n  constructor(\n    @inject(Symbol.for('IContainerOrchestrator'))\n    private containerOrchestrator: IContainerOrchestrator,\n    // ...\n  ) {}\n\n  async getAllServices(request: FastifyRequest) {\n    const containers = await this.containerOrchestrator.listContainers({ all: true });\n    // ...\n  }\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove dynamic Docker imports from controllers\n- [ ] Use injected IContainerOrchestrator throughout controllers\n- [ ] Ensure Docker client is singleton in DI container\n- [ ] Add tests to verify Docker client reuse\n- [ ] Measure performance improvement",
    "state": "CLOSED",
    "synced": true,
    "number": 184,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/184",
    "contentHash": "b0dbeacd7d789749e5cf86c913fb5e3aa511074deaf9ff4622d4485e2bf1980d"
  },
  {
    "title": "[MEDIUM] Direct Prisma Imports in Controllers Bypass DI",
    "labels": [
      "P2",
      "architecture",
      "refactoring"
    ],
    "body": "Several controllers import Prisma directly instead of using injected repositories, breaking dependency injection principles and making testing difficult.\n\n**Locations:**\n- `apps/api/src/controllers/ServiceController.ts:380-381, 419-420, 516-519`\n- `apps/api/src/controllers/DeploymentController.ts:84-85, 219-220`\n- `apps/api/src/controllers/AuthController.ts:235-238`\n\n**Current Code:**\n\n```typescript\nasync getServiceHealth(request: FastifyRequest, reply: FastifyReply) {\n  // ...\n  const { prisma } = await import('database');\n  const service = await prisma.service.findFirst({\n    where: { id, userId: user.id, deletedAt: null },\n  });\n  // ...\n}\n```\n\n**Issues:**\n\n- Breaks dependency injection pattern\n- Makes unit testing difficult (can't mock Prisma)\n- Inconsistent with the rest of the codebase\n- Dynamic imports add unnecessary overhead\n\n**Recommended Fix:**\n\n```typescript\nasync getServiceHealth(request: FastifyRequest, reply: FastifyReply) {\n  // ...\n  const service = await this.serviceRepository.findById(id);\n  if (!service || service.userId !== user.id || service.deletedAt) {\n    return reply.status(404).send({ error: 'Service not found' });\n  }\n  // ...\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove all direct Prisma imports from controllers\n- [ ] Use injected repositories consistently\n- [ ] Add missing repository methods if needed\n- [ ] Update unit tests to use mocked repositories\n- [ ] Document DI pattern in codebase guidelines",
    "state": "CLOSED",
    "synced": true,
    "number": 185,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/185",
    "contentHash": "4ee5e88828932945be770d151be19fd6b20b9466ba2ceff08dcc21fabbb115f9"
  },
  {
    "title": "[MEDIUM] Missing Input Validation for Protection Toggle Endpoint",
    "labels": [
      "P2",
      "security",
      "bug"
    ],
    "body": "The protection toggle endpoint manually validates the `deleteProtected` field without using Zod schema validation, inconsistent with other endpoints.\n\n**Location:**\n`apps/api/src/controllers/ServiceController.ts:352-355`\n\n**Current Code:**\n\n```typescript\nconst { deleteProtected } = request.body as { deleteProtected?: boolean };\n\nif (typeof deleteProtected !== 'boolean') {\n  return reply.status(400).send({ error: 'deleteProtected must be a boolean' });\n}\n```\n\n**Issues:**\n\n- Manual type assertion bypasses type safety\n- Inconsistent with Zod validation used elsewhere\n- Error format differs from other validation errors\n- Missing comprehensive input sanitization\n\n**Recommended Fix:**\n\n```typescript\nconst ProtectionToggleSchema = z.object({\n  deleteProtected: z.boolean(),\n});\n\nasync toggleProtection(request: FastifyRequest, reply: FastifyReply) {\n  let validatedData;\n  try {\n    validatedData = ProtectionToggleSchema.parse(request.body);\n  } catch (error) {\n    if (error instanceof ZodError) {\n      return reply.status(400).send({\n        error: 'Validation failed',\n        details: formatZodError(error),\n      });\n    }\n    throw error;\n  }\n  // ...\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create Zod schema for protection toggle\n- [ ] Use consistent validation pattern with other endpoints\n- [ ] Return consistent error format\n- [ ] Add tests for validation edge cases",
    "state": "CLOSED",
    "synced": true,
    "number": 186,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/186",
    "contentHash": "f4cfe779ac2383c5366afc64f72cbd87d7b505aa662d5f790ac538d59c022baa"
  },
  {
    "title": "[MEDIUM] Potential Race Condition in Organization Creation During GitHub Auth",
    "labels": [
      "P2",
      "bug",
      "concurrency"
    ],
    "body": "During GitHub authentication, personal organization creation happens without proper concurrency control, potentially creating duplicate organizations.\n\n**Location:**\n`apps/api/src/services/AuthenticationService.ts:99-104`\n\n**Current Code:**\n\n```typescript\n// Check if user has organizations, if not create a personal one\nconst userOrgs = await this.organizationService.getUserOrganizations(user.id);\nif (userOrgs.length === 0) {\n  await this.organizationService.createOrganization(`${user.username}'s Personal`, user.id);\n}\n```\n\n**Issues:**\n\n- Time-of-check to time-of-use (TOCTOU) vulnerability\n- Concurrent auth requests could create multiple organizations\n- No transaction wrapping the check-and-create operation\n- TODO comment in code acknowledges this issue\n\n**Recommended Fix:**\n\n```typescript\n// Use transaction with upsert pattern\nawait prisma.$transaction(async (tx) => {\n  const existingOrg = await tx.organization.findFirst({\n    where: {\n      members: {\n        some: { userId: user.id, role: Role.OWNER }\n      }\n    }\n  });\n  \n  if (!existingOrg) {\n    await this.organizationService.createOrganization(\n      `${user.username}'s Personal`,\n      user.id,\n      tx\n    );\n  }\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Wrap organization check-and-create in transaction\n- [ ] Use database constraints to prevent duplicates\n- [ ] Add unique constraint for user's personal organization\n- [ ] Add tests for concurrent authentication scenarios\n- [ ] Remove TODO comment after fixing",
    "state": "CLOSED",
    "synced": true,
    "number": 187,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/187",
    "contentHash": "4c13307a0a707e885c70ff384a260846f83faadfb7df823f167a2d7624e4051f"
  },
  {
    "title": "[MEDIUM] SSE Connection Cleanup May Leave Redis Subscriptions",
    "labels": [
      "P2",
      "bug",
      "reliability"
    ],
    "body": "In the deployment logs SSE endpoint, Redis subscription cleanup uses a shared connection for both subscribe and unsubscribe, which may not properly clean up subscriptions.\n\n**Location:**\n`apps/api/src/controllers/DeploymentController.ts:361-398`\n\n**Current Code:**\n\n```typescript\nconst subConnection = request.server.redis;\nconst channel = `deployment-logs:${id}`;\n\n// ...\n\nconst cleanup = async () => {\n  // ...\n  if (isSubscribed) {\n    try {\n      subConnection.removeListener('message', onMessage);\n      await subConnection.unsubscribe(channel);\n      isSubscribed = false;\n    } catch (err) {\n      console.error(`Error unsubscribing from channel ${channel}:`, err);\n    }\n  }\n};\n```\n\n**Issues:**\n\n- Using shared Redis connection for pub/sub can cause issues\n- Redis pub/sub requires dedicated connections\n- Subscription may not be properly cleaned up on connection errors\n- Could lead to memory leaks in Redis\n\n**Recommended Fix:**\n\n```typescript\n// Create dedicated subscriber connection\nconst subConnection = request.server.redis.duplicate();\n\nconst cleanup = async () => {\n  // ...\n  try {\n    await subConnection.unsubscribe(channel);\n    await subConnection.quit(); // Close dedicated connection\n  } catch (err) {\n    console.error(`Error cleaning up Redis subscription:`, err);\n  }\n};\n```\n\n**Acceptance Criteria:**\n\n- [ ] Use dedicated Redis connections for pub/sub\n- [ ] Properly close dedicated connections on cleanup\n- [ ] Add connection health monitoring\n- [ ] Add tests for subscription cleanup\n- [ ] Document Redis pub/sub pattern",
    "state": "CLOSED",
    "synced": true,
    "number": 188,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/188",
    "contentHash": "9594fd1055c46d0017b4ef867f1cf42d2405ea5e0783fe7a53bd60b0e5b56033"
  },
  {
    "title": "[MEDIUM] Feature Flag Client Makes Individual API Calls for Each Flag",
    "labels": [
      "P2",
      "performance",
      "frontend"
    ],
    "body": "The FeatureFlagClient's `checkMultiple` method makes separate API calls for each feature flag instead of batching them into a single request.\n\n**Location:**\n`apps/dashboard/src/lib/featureFlags.ts:44-54`\n\n**Current Code:**\n\n```typescript\nstatic async checkMultiple(keys: string[], userId?: string): Promise<Record<string, boolean>> {\n  const results: Record<string, boolean> = {};\n\n  await Promise.all(\n    keys.map(async (key) => {\n      results[key] = await this.isEnabled(key, userId);\n    }),\n  );\n\n  return results;\n}\n```\n\n**Performance Impact:**\n\n- N API calls for N feature flags\n- Increased latency for feature flag checks\n- Higher server load\n- Potential rate limiting issues\n\n**Recommended Fix:**\n\n```typescript\n// Backend: Add bulk check endpoint\n// POST /feature-flags/check-bulk\n// Body: { keys: string[], userId?: string }\n\n// Frontend:\nstatic async checkMultiple(keys: string[], userId?: string): Promise<Record<string, boolean>> {\n  try {\n    const response = await fetch(`${API_BASE_URL}/feature-flags/check-bulk`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ keys, userId }),\n    });\n    \n    if (!response.ok) {\n      return Object.fromEntries(keys.map(k => [k, false]));\n    }\n    \n    return response.json();\n  } catch (error) {\n    return Object.fromEntries(keys.map(k => [k, false]));\n  }\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add bulk feature flag check endpoint to API\n- [ ] Update FeatureFlagClient to use bulk endpoint\n- [ ] Add caching for feature flag results\n- [ ] Add tests for bulk check functionality\n- [ ] Document API endpoint",
    "state": "CLOSED",
    "synced": true,
    "number": 189,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/189",
    "contentHash": "23f9240207b52076f0b205c7381852cf680a1bb87ac792ad49680d84acff71d2"
  },
  {
    "title": "[MEDIUM] Error Boundary Does Not Report Errors to Monitoring Service",
    "labels": [
      "P2",
      "observability",
      "frontend"
    ],
    "body": "The React ErrorBoundary only logs errors to console without reporting to any error monitoring service (e.g., Sentry).\n\n**Location:**\n`apps/dashboard/src/components/ErrorBoundary.tsx:26-28`\n\n**Current Code:**\n\n```typescript\ncomponentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n  console.error('ErrorBoundary caught an error:', error, errorInfo);\n}\n```\n\n**Issues:**\n\n- Production errors are not tracked\n- No visibility into client-side failures\n- Cannot correlate frontend errors with backend issues\n- Missing error context (user, route, etc.)\n\n**Recommended Fix:**\n\n```typescript\nimport * as Sentry from '@sentry/nextjs';\n\ncomponentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {\n  console.error('ErrorBoundary caught an error:', error, errorInfo);\n  \n  // Report to error monitoring\n  Sentry.captureException(error, {\n    contexts: {\n      react: {\n        componentStack: errorInfo.componentStack,\n      },\n    },\n  });\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Choose and integrate error monitoring service (Sentry recommended)\n- [ ] Update ErrorBoundary to report errors\n- [ ] Add user context to error reports\n- [ ] Add route/page context to error reports\n- [ ] Document error monitoring setup\n- [ ] Add source maps for better stack traces",
    "state": "CLOSED",
    "synced": true,
    "number": 190,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/190",
    "contentHash": "09abf0df5f55300903032fe3467b7f23217beae981715a7a91317fad088bd0b5"
  },
  {
    "title": "[MEDIUM] Webhook Controller Uses Direct Prisma Import Instead of Repositories",
    "labels": [
      "P2",
      "architecture",
      "refactoring"
    ],
    "body": "The WebhookController imports Prisma directly in several places instead of using injected repositories, creating inconsistency with the DI pattern.\n\n**Location:**\n`apps/api/src/controllers/WebhookController.ts:321-364, 374-379, 422-429`\n\n**Current Code:**\n\n```typescript\nasync handlePullRequestEvent(...) {\n  // ...\n  const { prisma } = await import('database');\n  const baseService = await prisma.service.findFirst({\n    where: { ... },\n  });\n  // ...\n  const service = await prisma.service.upsert({ ... });\n}\n```\n\n**Issues:**\n\n- Inconsistent with DI pattern used elsewhere\n- Dynamic imports add overhead\n- Makes testing difficult\n- Cannot easily mock database in tests\n\n**Recommended Fix:**\n\nUse the injected `IServiceRepository` throughout the controller:\n\n```typescript\nasync handlePullRequestEvent(...) {\n  const baseService = await this.serviceRepository.findByRepoAndBranch(\n    repoUrl,\n    { isPreview: false, deletedAt: null }\n  );\n  // ...\n  const service = await this.serviceRepository.upsertPreview(...);\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Remove direct Prisma imports from WebhookController\n- [ ] Add necessary methods to IServiceRepository interface\n- [ ] Implement new repository methods\n- [ ] Update tests to use mocked repositories\n- [ ] Follow consistent DI pattern",
    "state": "CLOSED",
    "synced": true,
    "number": 191,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/191",
    "contentHash": "996b1b7029aa5b8a0b87dff9f00f5941c9cd20004c5dca6982f6ec1a35b7c3a1"
  },
  {
    "title": "[LOW] Duplicate Constants Definition Between API and Worker",
    "labels": [
      "P3",
      "refactoring",
      "maintainability"
    ],
    "body": "Container resource limit constants are duplicated between API and Worker services, violating DRY principles.\n\n**Locations:**\n- `apps/api/src/config/constants.ts:7-14`\n- `apps/worker/src/config/constants.ts:7-14`\n\n**Current Code (both files):**\n\n```typescript\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\nexport const CONTAINER_MEMORY_LIMIT_BYTES = CONTAINER_MEMORY_LIMIT_MB * 1024 * 1024;\n\nexport const CONTAINER_CPU_CORES = parseFloat(process.env.CONTAINER_CPU_CORES || '1.0');\nexport const CONTAINER_CPU_NANOCPUS = Math.floor(CONTAINER_CPU_CORES * 1000000000);\n```\n\n**Issues:**\n\n- Same constants defined in two places\n- Changes must be made in both files\n- Risk of configuration drift\n- Harder to maintain\n\n**Recommended Fix:**\n\nMove shared constants to the `packages/shared` package:\n\n```typescript\n// packages/shared/src/config/constants.ts\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\n// ...\n\n// apps/api/src/config/constants.ts\nexport { CONTAINER_MEMORY_LIMIT_MB, CONTAINER_CPU_NANOCPUS } from 'shared';\n// ... API-specific constants\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create shared constants file in packages/shared\n- [ ] Move common constants to shared package\n- [ ] Update imports in API and Worker\n- [ ] Remove duplicate definitions\n- [ ] Add tests for shared constants",
    "state": "CLOSED",
    "synced": true,
    "number": 192,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/192",
    "contentHash": "d60e86cadbd41e262b3679126a4170a0f24c62ae955422ed68cd869016bd8dfd"
  },
  {
    "title": "[LOW] Missing Error Handling for Config Parsing in Constants",
    "labels": [
      "P3",
      "reliability",
      "enhancement"
    ],
    "body": "Environment variable parsing in constants files doesn't handle invalid values gracefully, potentially causing silent failures or NaN values.\n\n**Locations:**\n- `apps/api/src/config/constants.ts`\n- `apps/worker/src/config/constants.ts`\n\n**Current Code:**\n\n```typescript\nexport const CONTAINER_MEMORY_LIMIT_MB = parseInt(\n  process.env.CONTAINER_MEMORY_LIMIT_MB || '512',\n  10,\n);\nexport const CONTAINER_CPU_CORES = parseFloat(process.env.CONTAINER_CPU_CORES || '1.0');\n```\n\n**Issues:**\n\n- Invalid string values result in NaN\n- No validation of reasonable ranges\n- Silent failures could cause unexpected behavior\n- No logging of configuration issues\n\n**Recommended Fix:**\n\n```typescript\nfunction parseIntEnv(name: string, defaultValue: number, min?: number, max?: number): number {\n  const raw = process.env[name];\n  if (!raw) return defaultValue;\n  \n  const parsed = parseInt(raw, 10);\n  if (isNaN(parsed)) {\n    console.warn(`Invalid ${name} value '${raw}', using default ${defaultValue}`);\n    return defaultValue;\n  }\n  \n  if (min !== undefined && parsed < min) {\n    console.warn(`${name} value ${parsed} below minimum ${min}, using ${min}`);\n    return min;\n  }\n  \n  if (max !== undefined && parsed > max) {\n    console.warn(`${name} value ${parsed} above maximum ${max}, using ${max}`);\n    return max;\n  }\n  \n  return parsed;\n}\n\nexport const CONTAINER_MEMORY_LIMIT_MB = parseIntEnv(\n  'CONTAINER_MEMORY_LIMIT_MB',\n  512,\n  64,    // Minimum 64MB\n  8192   // Maximum 8GB\n);\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create safe parsing utility functions\n- [ ] Add range validation for numeric configs\n- [ ] Log warnings for invalid/out-of-range values\n- [ ] Add tests for edge cases\n- [ ] Document valid configuration ranges",
    "state": "CLOSED",
    "synced": true,
    "number": 193,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/193",
    "contentHash": "1d03e2e4135c3abfea6cf71d3509c26a493424ff1f9a130458ecb4c83e80d411"
  },
  {
    "title": "[LOW] Hardcoded Platform Domain in Multiple Locations",
    "labels": [
      "P3",
      "maintainability",
      "refactoring"
    ],
    "body": "The platform domain `helvetia.cloud` is hardcoded in multiple places instead of being centrally configured.\n\n**Locations:**\n- `apps/api/src/controllers/DeploymentController.ts:139-140`\n- Various Traefik label configurations\n\n**Current Code:**\n\n```typescript\nconst traefikRule = service.customDomain\n  ? `Host(\\`${service.name}.${process.env.PLATFORM_DOMAIN || 'helvetia.cloud'}\\`) || ...`\n  : `Host(\\`${service.name}.${process.env.PLATFORM_DOMAIN || 'helvetia.cloud'}\\`) || ...`;\n```\n\n**Issues:**\n\n- Domain string repeated with same fallback pattern\n- Risk of inconsistent domain usage\n- Harder to rebrand or deploy to different domains\n- Should be a centralized constant\n\n**Recommended Fix:**\n\n```typescript\n// packages/shared/src/config/constants.ts\nexport const PLATFORM_DOMAIN = process.env.PLATFORM_DOMAIN || 'helvetia.cloud';\n\n// apps/api/src/controllers/DeploymentController.ts\nimport { PLATFORM_DOMAIN } from 'shared';\n\nconst traefikRule = service.customDomain\n  ? `Host(\\`${service.name}.${PLATFORM_DOMAIN}\\`) || ...`\n  : `Host(\\`${service.name}.${PLATFORM_DOMAIN}\\`) || ...`;\n```\n\n**Acceptance Criteria:**\n\n- [ ] Create PLATFORM_DOMAIN constant in shared package\n- [ ] Replace all hardcoded domain references\n- [ ] Document domain configuration\n- [ ] Add validation for domain format",
    "state": "CLOSED",
    "synced": true,
    "number": 194,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/194",
    "contentHash": "e06a4a8261c5721a4510bb3f48ad409540bda757c91c93550a96adecdc7ea374"
  },
  {
    "title": "[LOW] useFeatureFlag Hook Missing Dependency in useEffect",
    "labels": [
      "P3",
      "frontend",
      "bug"
    ],
    "body": "The `useFeatureFlag` hook's useEffect may have stale closure issues due to missing dependencies in the dependency array.\n\n**Location:**\n`apps/dashboard/src/lib/featureFlags.ts:68-79`\n\n**Current Code:**\n\n```typescript\nexport function useFeatureFlag(\n  key: string,\n  userId?: string,\n  options: { enabled?: boolean } = { enabled: true },\n) {\n  const [enabled, setEnabled] = React.useState<boolean>(false);\n  const [loading, setLoading] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    if (!options.enabled) {\n      setEnabled(false);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    FeatureFlagClient.isEnabled(key, userId)\n      .then(setEnabled)\n      .finally(() => setLoading(false));\n  }, [key, userId, options.enabled]);\n\n  return { enabled, loading };\n}\n```\n\n**Issues:**\n\n- `options.enabled` should be extracted before the effect\n- Default parameter creates new object on each render\n- Could cause unnecessary re-renders\n\n**Recommended Fix:**\n\n```typescript\nexport function useFeatureFlag(\n  key: string,\n  userId?: string,\n  options?: { enabled?: boolean },\n) {\n  const isEnabled = options?.enabled ?? true;\n  const [enabled, setEnabled] = React.useState<boolean>(false);\n  const [loading, setLoading] = React.useState<boolean>(true);\n\n  React.useEffect(() => {\n    if (!isEnabled) {\n      setEnabled(false);\n      setLoading(false);\n      return;\n    }\n\n    setLoading(true);\n    FeatureFlagClient.isEnabled(key, userId)\n      .then(setEnabled)\n      .finally(() => setLoading(false));\n  }, [key, userId, isEnabled]);\n\n  return { enabled, loading };\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Fix options parameter handling\n- [ ] Extract enabled flag before useEffect\n- [ ] Ensure stable dependencies\n- [ ] Add tests for hook behavior",
    "state": "CLOSED",
    "synced": true,
    "number": 195,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/195",
    "contentHash": "9a373f1449b090891308d5342dab98d8bf7efebbed3ccf15739b95a530f4ef4d"
  },
  {
    "title": "[LOW] Services Hook Returns Status String Instead of Proper Enum Type",
    "labels": [
      "P3",
      "type-safety",
      "frontend"
    ],
    "body": "The `createUpdateServiceMetrics` function casts metrics status to `ServiceStatus` without proper type checking, potentially allowing invalid status values.\n\n**Location:**\n`apps/dashboard/src/hooks/useServices.ts:279-296`\n\n**Current Code:**\n\n```typescript\nexport function createUpdateServiceMetrics(queryClient: ReturnType<typeof useQueryClient>) {\n  return (updates: Array<{ id: string; metrics: Service['metrics']; status?: ServiceStatus }>) => {\n    queryClient.setQueryData<Service[]>(serviceKeys.lists(), (old) =>\n      old\n        ? old.map((service) => {\n            const update = updates.find((u) => u.id === service.id);\n            if (update && update.metrics) {\n              return {\n                ...service,\n                metrics: update.metrics,\n                status: (update.metrics.status as ServiceStatus) || service.status,\n              };\n            }\n            return service;\n          })\n        : old,\n    );\n  };\n}\n```\n\n**Issues:**\n\n- Unsafe type assertion `as ServiceStatus`\n- Could result in invalid status values in state\n- No runtime validation of status values\n\n**Recommended Fix:**\n\n```typescript\nconst VALID_STATUSES: ServiceStatus[] = ['IDLE', 'DEPLOYING', 'RUNNING', 'STOPPED', 'FAILED'];\n\nfunction isValidStatus(status: unknown): status is ServiceStatus {\n  return typeof status === 'string' && VALID_STATUSES.includes(status as ServiceStatus);\n}\n\nexport function createUpdateServiceMetrics(queryClient: ReturnType<typeof useQueryClient>) {\n  return (updates: Array<{ id: string; metrics: Service['metrics']; status?: ServiceStatus }>) => {\n    queryClient.setQueryData<Service[]>(serviceKeys.lists(), (old) =>\n      old?.map((service) => {\n        const update = updates.find((u) => u.id === service.id);\n        if (update?.metrics) {\n          const newStatus = update.metrics.status;\n          return {\n            ...service,\n            metrics: update.metrics,\n            status: isValidStatus(newStatus) ? newStatus : service.status,\n          };\n        }\n        return service;\n      }) ?? old,\n    );\n  };\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Add runtime status validation\n- [ ] Create type guard for ServiceStatus\n- [ ] Remove unsafe type assertions\n- [ ] Add tests for status updates",
    "state": "CLOSED",
    "synced": true,
    "number": 196,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/196",
    "contentHash": "9d4bb0a248c2dc99c948e32c451cbde7f07412582405f02c93f1f0726095b662"
  },
  {
    "title": "[MEDIUM] Theme Switcher Implementation",
    "labels": [
      "P2",
      "enhancement",
      "ui/ux",
      "frontend"
    ],
    "body": "Allow users to manually switch between light and dark themes in the main menu, independent of system preferences.\n\n**Current State:**\n- Dark/Light mode exists with system-aware theming support\n- No manual theme switcher UI component\n\n**Requirements:**\n\n- Add theme switcher toggle/button to main menu\n- Persist user's theme preference (localStorage/cookies)\n- Override system theme when user has explicit preference\n- Smooth transitions between themes\n- Accessible controls with proper ARIA labels\n\n**Acceptance Criteria:**\n\n- [ ] Design theme switcher component (toggle or dropdown)\n- [ ] Add theme switcher to main menu/navigation\n- [ ] Implement theme state management\n- [ ] Persist theme preference across sessions\n- [ ] Handle system theme vs user preference priority\n- [ ] Add smooth theme transition animations\n- [ ] Ensure accessibility (keyboard navigation, ARIA labels)\n- [ ] Test on all pages and components\n- [ ] Update documentation",
    "state": "CLOSED",
    "synced": true,
    "number": 227,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/227",
    "contentHash": "33ae418435f79b3a47abaf832b3ceae1635b55c8bb09dc93916994be797684c0"
  },
  {
    "title": "[MEDIUM] Modern Login Page Design",
    "labels": [
      "P2",
      "enhancement",
      "ui/ux",
      "frontend"
    ],
    "body": "Create a modern, engaging login page that matches the platform's premium glassmorphic aesthetic.\n\n**Current State:**\n- GitHub OAuth integration is complete\n- Login flow is functional\n- Login page needs visual polish and branding\n\n**Requirements:**\n\n- Premium glassmorphic design consistent with landing page\n- Clear value proposition and call-to-action\n- GitHub OAuth button with appropriate branding\n- Responsive design for all screen sizes\n- Loading states and error handling\n- Optional: Email/password login for admin accounts\n\n**Design Elements:**\n\n- Platform logo and branding\n- Hero section with key benefits\n- Prominent \"Sign in with GitHub\" button\n- Security/privacy messaging\n- Links to Terms of Service and Privacy Policy\n- Mobile-friendly layout\n\n**Acceptance Criteria:**\n\n- [ ] Design login page mockup\n- [ ] Implement glassmorphic UI components\n- [ ] Add GitHub OAuth button with proper styling\n- [ ] Include security/privacy messaging\n- [ ] Implement loading and error states\n- [ ] Ensure mobile responsiveness\n- [ ] Add proper meta tags for SEO\n- [ ] Test authentication flow\n- [ ] Accessibility compliance (WCAG 2.1 AA)\n- [ ] Update screenshots in documentation",
    "state": "CLOSED",
    "synced": true,
    "number": 228,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/228",
    "contentHash": "dca5334d6b389512de43a8a4544e24bc77244fdba86aa37d43f5c53193901c36"
  },
  {
    "title": "[HIGH] Team Collaboration & Organizations",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "backend",
      "frontend"
    ],
    "body": "Implement team collaboration features including organizations, member management, and Role-Based Access Control (RBAC).\n\n**Current State:**\n- Single-user accounts only\n- No team or organization support\n- Basic user authentication exists\n\n**Features Required:**\n\n### Organizations\n- Create and manage organizations\n- Organization settings (name, avatar, billing)\n- Transfer services between personal and org accounts\n\n### Member Management\n- Invite members via email\n- Accept/decline invitations\n- Remove members\n- View member activity\n\n### RBAC (Role-Based Access Control)\n- Owner: Full admin access\n- Admin: Manage members and services\n- Developer: Deploy and manage services\n- Viewer: Read-only access\n\n### Permissions\n- Service-level permissions\n- Deployment permissions\n- Settings and billing access control\n\n**Database Schema Changes:**\n\n```prisma\nmodel Organization {\n  id        String   @id @default(cuid())\n  name      String\n  slug      String   @unique\n  avatar    String?\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  members   OrganizationMember[]\n  services  Service[]\n}\n\nmodel OrganizationMember {\n  id             String   @id @default(cuid())\n  organizationId String\n  userId         String\n  role           Role\n  createdAt      DateTime @default(now())\n  updatedAt      DateTime @updatedAt\n\n  organization Organization @relation(fields: [organizationId], references: [id])\n  user         User         @relation(fields: [userId], references: [id])\n\n  @@unique([organizationId, userId])\n}\n\nenum Role {\n  OWNER\n  ADMIN\n  DEVELOPER\n  VIEWER\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Design organization data model\n- [ ] Create database migrations\n- [ ] Implement organization CRUD APIs\n- [ ] Implement member management APIs\n- [ ] Add RBAC middleware for permission checks\n- [ ] Create organization dashboard UI\n- [ ] Build member invitation system\n- [ ] Add role management interface\n- [ ] Update service creation to support organizations\n- [ ] Add organization context switching\n- [ ] Implement audit logging for org actions\n- [ ] Add comprehensive tests\n- [ ] Update documentation\n- [ ] Migration path for existing users",
    "state": "CLOSED",
    "synced": true,
    "number": 229,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/229",
    "contentHash": "ab6ed8a3a79fc2b001c5ecf4ecd9366cfc0887283bd4c98e76b11288cbdacc5e"
  },
  {
    "title": "[HIGH] Billing Integration with Stripe",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "backend",
      "frontend",
      "billing"
    ],
    "body": "Integrate Stripe for usage-based pricing and subscription management.\n\n**Current State:**\n- No billing or payment system\n- All services are free\n- No resource usage tracking for billing\n\n**Pricing Model:**\n\n- Free tier with limitations\n- Usage-based pricing (compute hours, memory, bandwidth)\n- Subscription tiers (Starter, Pro, Enterprise)\n- Pay-as-you-go option\n\n**Features Required:**\n\n### Stripe Integration\n- Stripe account connection\n- Payment method management\n- Subscription creation and updates\n- Usage-based billing\n- Invoice generation\n\n### Usage Tracking\n- Track compute hours per service\n- Track memory usage\n- Track bandwidth/data transfer\n- Track database storage\n- Real-time usage monitoring\n\n### Billing Dashboard\n- Current usage and costs\n- Payment history\n- Invoices and receipts\n- Usage forecasts\n- Upgrade/downgrade plans\n\n### Enforcement\n- Resource limits per tier\n- Graceful degradation for unpaid accounts\n- Automatic service suspension\n- Payment retry logic\n\n**Database Schema:**\n\n```prisma\nmodel Subscription {\n  id                 String   @id @default(cuid())\n  userId             String?\n  organizationId     String?\n  stripeCustomerId   String   @unique\n  stripeSubscriptionId String? @unique\n  plan               SubscriptionPlan\n  status             SubscriptionStatus\n  currentPeriodStart DateTime\n  currentPeriodEnd   DateTime\n  createdAt          DateTime @default(now())\n  updatedAt          DateTime @updatedAt\n\n  user         User?         @relation(fields: [userId], references: [id])\n  organization Organization? @relation(fields: [organizationId], references: [id])\n}\n\nenum SubscriptionPlan {\n  FREE\n  STARTER\n  PRO\n  ENTERPRISE\n}\n\nenum SubscriptionStatus {\n  ACTIVE\n  PAST_DUE\n  CANCELED\n  UNPAID\n}\n\nmodel UsageRecord {\n  id          String   @id @default(cuid())\n  serviceId   String\n  metric      UsageMetric\n  quantity    Float\n  timestamp   DateTime\n  periodStart DateTime\n  periodEnd   DateTime\n\n  service Service @relation(fields: [serviceId], references: [id])\n}\n\nenum UsageMetric {\n  COMPUTE_HOURS\n  MEMORY_GB_HOURS\n  BANDWIDTH_GB\n  STORAGE_GB\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Set up Stripe account and API keys\n- [ ] Implement Stripe webhook handlers\n- [ ] Create subscription management APIs\n- [ ] Build usage tracking system\n- [ ] Implement metering for billable resources\n- [ ] Create billing dashboard UI\n- [ ] Add payment method management\n- [ ] Implement plan upgrade/downgrade\n- [ ] Add invoice viewing and download\n- [ ] Implement resource limit enforcement\n- [ ] Add grace period for failed payments\n- [ ] Create admin billing tools\n- [ ] Add comprehensive tests\n- [ ] Document pricing structure\n- [ ] Legal review of terms\n- [ ] PCI compliance verification",
    "state": "CLOSED",
    "synced": true,
    "number": 230,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/230",
    "contentHash": "3ca479b8178e392b822de8f30351c38f563b2dfd4e9dd86ea4cde8ddeb1ee051"
  },
  {
    "title": "[MEDIUM] One-Click Application Marketplace",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "backend",
      "frontend"
    ],
    "body": "Create a marketplace for one-click deployment of popular open-source applications.\n\n**Current State:**\n- Users manually configure services\n- No template or marketplace system\n- Each deployment requires full configuration\n\n**Applications to Include:**\n\n- **Content Management:** WordPress, Ghost, Strapi\n- **Analytics:** Plausible, Umami, Matomo\n- **Databases:** PostgreSQL, MySQL, Redis, MongoDB\n- **Development Tools:** GitLab, Jenkins, SonarQube\n- **Communication:** Mattermost, Rocket.Chat\n- **E-commerce:** WooCommerce, Magento\n- **Project Management:** Taiga, Wekan\n- **Monitoring:** Grafana, Prometheus\n\n**Features:**\n\n### Marketplace UI\n- Browse available applications\n- Search and filter by category\n- Application details and requirements\n- User ratings and reviews\n- Quick deploy button\n\n### Application Templates\n- Pre-configured Docker Compose files\n- Environment variable templates\n- Default resource allocations\n- Health check configurations\n- Documentation links\n\n### One-Click Deploy\n- Guided setup wizard\n- Automatic dependency resolution\n- Environment variable input\n- Domain configuration\n- SSL certificate generation\n\n### Template Management\n- Community-contributed templates\n- Official verified templates\n- Template versioning\n- Update notifications\n\n**Database Schema:**\n\n```prisma\nmodel ApplicationTemplate {\n  id          String   @id @default(cuid())\n  name        String\n  slug        String   @unique\n  description String\n  category    String\n  icon        String\n  author      String\n  official    Boolean  @default(false)\n  version     String\n  minMemory   Int      // MB\n  minCpu      Float\n  compose     String   // Docker Compose YAML\n  envVars     Json     // Required env vars with descriptions\n  ports       Json     // Exposed ports\n  volumes     Json     // Required volumes\n  readme      String\n  createdAt   DateTime @default(now())\n  updatedAt   DateTime @updatedAt\n\n  deployments Service[]\n}\n```\n\n**Acceptance Criteria:**\n\n- [ ] Design marketplace UI/UX\n- [ ] Create application template schema\n- [ ] Build template management system\n- [ ] Add 10+ popular application templates\n- [ ] Implement one-click deploy workflow\n- [ ] Create guided setup wizard\n- [ ] Add search and filtering\n- [ ] Implement application categories\n- [ ] Add template versioning\n- [ ] Create template contribution guide\n- [ ] Add template validation and security scanning\n- [ ] Implement user reviews/ratings\n- [ ] Add template update notifications\n- [ ] Write documentation for each template\n- [ ] Add comprehensive tests",
    "state": "OPEN",
    "synced": true,
    "number": 231,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/231",
    "contentHash": "f916ea94223b87bdc0f828bedd5d68b002886097375aa4d4c037367a453b290a"
  },
  {
    "title": "[MEDIUM] Helvetia Cloud CLI Tool",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "cli",
      "developer-experience"
    ],
    "body": "Create a specialized command-line tool for Helvetia Cloud to enable developers to manage services, deployments, and resources from the terminal.\n\n**Current State:**\n- Web dashboard only\n- No CLI tool\n- Manual API calls for automation\n\n**Core Features:**\n\n### Authentication\n```bash\nhelvetia login\nhelvetia logout\nhelvetia whoami\n```\n\n### Service Management\n```bash\nhelvetia services list\nhelvetia services create <name> --repo <url> --branch <branch>\nhelvetia services get <id>\nhelvetia services update <id> --env KEY=VALUE\nhelvetia services delete <id>\nhelvetia services logs <id> --follow\nhelvetia services metrics <id>\n```\n\n### Deployments\n```bash\nhelvetia deploy <service-id>\nhelvetia deployments list <service-id>\nhelvetia deployments logs <deployment-id>\nhelvetia rollback <service-id> <deployment-id>\n```\n\n### Databases\n```bash\nhelvetia db create postgres --name mydb\nhelvetia db list\nhelvetia db connect <db-id>\nhelvetia db backup <db-id>\nhelvetia db restore <db-id> <backup-id>\n```\n\n### Environment Variables\n```bash\nhelvetia env list <service-id>\nhelvetia env set <service-id> KEY=VALUE\nhelvetia env unset <service-id> KEY\nhelvetia env pull <service-id> --file .env\nhelvetia env push <service-id> --file .env\n```\n\n### Domains\n```bash\nhelvetia domains list <service-id>\nhelvetia domains add <service-id> <domain>\nhelvetia domains remove <service-id> <domain>\n```\n\n### Organizations\n```bash\nhelvetia orgs list\nhelvetia orgs switch <org-id>\nhelvetia orgs members list <org-id>\nhelvetia orgs members add <org-id> <email> --role developer\n```\n\n**Technical Requirements:**\n\n- Written in Go or Node.js\n- Cross-platform (Windows, macOS, Linux)\n- Interactive and non-interactive modes\n- Colored output and progress indicators\n- Configuration file support (~/.helvetia/config.yaml)\n- API token management\n- Auto-completion for shells (bash, zsh, fish)\n- Update notifications\n\n**Additional Features:**\n\n- `helvetia init` - Initialize a new project\n- `helvetia status` - Show service health status\n- `helvetia scale <service-id> --replicas 3` - Scale services\n- `helvetia exec <service-id> -- <command>` - Execute commands in container\n- `helvetia port-forward <service-id> 8080:80` - Port forwarding\n- `helvetia marketplace list` - Browse marketplace templates\n- `helvetia marketplace deploy <template>` - Deploy from marketplace\n\n**Acceptance Criteria:**\n\n- [ ] Choose technology stack (Go/Node.js)\n- [ ] Set up CLI project structure\n- [ ] Implement authentication flow\n- [ ] Build service management commands\n- [ ] Add deployment commands\n- [ ] Implement database commands\n- [ ] Add environment variable management\n- [ ] Implement organization commands\n- [ ] Add interactive prompts for common tasks\n- [ ] Create configuration file system\n- [ ] Add shell auto-completion\n- [ ] Implement colored output and formatting\n- [ ] Add progress indicators\n- [ ] Create installation scripts\n- [ ] Publish to package managers (npm, brew, apt)\n- [ ] Write comprehensive documentation\n- [ ] Add unit and integration tests\n- [ ] Create demo video/GIF",
    "state": "OPEN",
    "synced": true,
    "number": 232,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/232",
    "contentHash": "0ed62f11d646524d14887dea8b4499a0e566df385c41749b0db71ca3b61ecaf7"
  },
  {
    "title": "[HIGH] Comprehensive API Documentation",
    "labels": [
      "P1",
      "documentation",
      "enhancement"
    ],
    "body": "Create comprehensive API documentation for the Helvetia Cloud platform to enable third-party integrations and developer adoption.\n\n**Current State:**\n- No public API documentation\n- Endpoints are not formally documented\n- No API reference or interactive explorer\n\n**Documentation Requirements:**\n\n### API Reference\n- Complete endpoint listing\n- Request/response schemas\n- Authentication methods\n- Error codes and messages\n- Rate limiting details\n- Versioning strategy\n\n### Interactive Documentation\n- OpenAPI/Swagger specification\n- Try-it-out functionality\n- Code examples in multiple languages\n- Authentication playground\n\n### Getting Started Guide\n- Quick start tutorial\n- Authentication setup\n- Common use cases\n- Best practices\n- SDK installation (if available)\n\n**Technology Options:**\n\n- **OpenAPI/Swagger**: Industry standard, great tooling\n- **Redoc**: Clean, responsive documentation\n- **Docusaurus**: Full documentation site\n- **Stoplight**: API design and documentation\n\n**Endpoints to Document:**\n\n### Authentication\n- POST /auth/github\n- POST /auth/logout\n- GET /auth/verify\n\n### Services\n- GET /services\n- POST /services\n- GET /services/:id\n- PATCH /services/:id\n- DELETE /services/:id\n- POST /services/:id/deploy\n- GET /services/:id/metrics\n- GET /services/:id/logs\n\n### Deployments\n- GET /deployments\n- GET /deployments/:id\n- GET /deployments/:id/logs\n\n### Databases\n- GET /databases\n- POST /databases\n- GET /databases/:id\n- DELETE /databases/:id\n\n### Organizations (future)\n- GET /organizations\n- POST /organizations\n- GET /organizations/:id/members\n- POST /organizations/:id/members\n\n### Webhooks\n- POST /webhooks/github\n\n**Acceptance Criteria:**\n\n- [ ] Generate OpenAPI specification from code\n- [ ] Set up documentation site (Redoc/Stoplight)\n- [ ] Document all public API endpoints\n- [ ] Add request/response examples\n- [ ] Include authentication guide\n- [ ] Document error codes\n- [ ] Add rate limiting information\n- [ ] Create getting started tutorial\n- [ ] Add code examples (cURL, JavaScript, Python)\n- [ ] Include webhook documentation\n- [ ] Add API versioning strategy\n- [ ] Create SDKs for popular languages (optional)\n- [ ] Set up automatic documentation updates\n- [ ] Add API changelog\n- [ ] Include security best practices\n- [ ] Make documentation publicly accessible",
    "state": "CLOSED",
    "synced": true,
    "number": 233,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/233",
    "contentHash": "e56537c93bb6f95ea8d3f9a1e44ae0541918bc8750611dd08976d7aa46d7aee2"
  },
  {
    "title": "[HIGH] User Documentation & Guides",
    "labels": [
      "P1",
      "documentation",
      "enhancement",
      "user-experience"
    ],
    "body": "Create comprehensive user documentation to help users understand and effectively use the Helvetia Cloud platform.\n\n**Current State:**\n- Limited documentation\n- No user guides or tutorials\n- Only developer-focused README\n\n**Documentation Structure:**\n\n### Getting Started\n- Platform overview\n- Account creation\n- First deployment tutorial\n- Dashboard walkthrough\n- Basic concepts (services, deployments, environments)\n\n### How-To Guides\n- Deploy a Node.js application\n- Deploy a static site (React, Vue, Angular)\n- Deploy a Docker application\n- Deploy a database\n- Set up custom domains\n- Configure SSL certificates\n- Manage environment variables\n- View logs and metrics\n- Set up webhooks for auto-deployment\n- Create preview environments\n- Scale services\n- Backup and restore databases\n\n### Service Types\n- Docker services\n- Static site services\n- Database services (PostgreSQL, MySQL, Redis)\n- Docker Compose services\n- Preview environments\n\n### Features\n- Real-time logs streaming\n- Container metrics and monitoring\n- Zero-downtime deployments\n- Health checks\n- Custom domains\n- Environment variable management\n- GitHub integration\n- Webhook automation\n\n### Best Practices\n- Security guidelines\n- Performance optimization\n- Resource allocation\n- Environment management\n- CI/CD integration\n- Monitoring and alerting\n\n### Troubleshooting\n- Common deployment issues\n- Build failures\n- Container crashes\n- Connection problems\n- Performance issues\n- FAQ\n\n### Reference\n- Environment variables\n- Docker image requirements\n- Resource limits\n- Port configuration\n- Health check configuration\n- Supported frameworks and languages\n\n**Documentation Platform:**\n\nOptions:\n- **Docusaurus**: Full-featured documentation site\n- **GitBook**: Beautiful, easy-to-use\n- **Read the Docs**: Classic documentation hosting\n- **Custom Next.js site**: Full control, matches branding\n\n**Features:**\n\n- Search functionality\n- Version support\n- Dark/light mode\n- Mobile responsive\n- Code syntax highlighting\n- Interactive examples\n- Video tutorials\n- Screenshots and GIFs\n- Multi-language support (EN, DE, FR, IT)\n\n**Acceptance Criteria:**\n\n- [ ] Choose documentation platform\n- [ ] Set up documentation site structure\n- [ ] Write Getting Started guide\n- [ ] Create deployment tutorials for each service type\n- [ ] Document all platform features\n- [ ] Add troubleshooting guides\n- [ ] Include best practices documentation\n- [ ] Add screenshots and diagrams\n- [ ] Create video tutorials (optional)\n- [ ] Implement search functionality\n- [ ] Ensure mobile responsiveness\n- [ ] Add multi-language support\n- [ ] Set up feedback mechanism\n- [ ] Create table of contents and navigation\n- [ ] Add related articles linking\n- [ ] Include glossary of terms\n- [ ] Make documentation publicly accessible\n- [ ] Set up analytics to track usage",
    "state": "OPEN",
    "synced": true,
    "number": 234,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/234",
    "contentHash": "52ee05cfe5e4763eadc9ac31ee6639c3ab0fe8dc1e096e53f0408bea843cfd1a"
  },
  {
    "title": "[HIGH] Privacy Policy",
    "labels": [
      "P1",
      "legal",
      "compliance",
      "documentation"
    ],
    "body": "Create a comprehensive privacy policy for the Helvetia Cloud platform to ensure GDPR and DSGVO compliance and build user trust.\n\n**Current State:**\n- No privacy policy\n- GDPR and DSGVO compliance implemented in code\n- No public documentation of data practices\n\n**Requirements:**\n\n### Legal Framework\n- GDPR (General Data Protection Regulation) compliant\n- DSGVO (Datenschutz-Grundverordnung) compliant\n- Swiss data protection law compliant\n- ePrivacy Directive compliant\n\n### Content to Include:\n\n#### 1. Introduction\n- Who we are\n- Contact information\n- Data controller details\n\n#### 2. Data We Collect\n- Account information (email, username, GitHub profile)\n- Service data (repositories, deployments, logs)\n- Usage data (analytics, metrics)\n- Technical data (IP addresses, browser info)\n- Cookies and tracking technologies\n\n#### 3. How We Use Data\n- Provide platform services\n- Improve user experience\n- Security and fraud prevention\n- Communication and support\n- Legal compliance\n\n#### 4. Data Storage & Processing\n- Where data is stored (Switzerland)\n- How long data is retained\n- Data security measures\n- Encryption practices\n\n#### 5. Data Sharing\n- Third-party services (GitHub, Stripe)\n- Service providers\n- Legal requirements\n- No data selling policy\n\n#### 6. User Rights (GDPR)\n- Right to access\n- Right to rectification\n- Right to erasure (\"right to be forgotten\")\n- Right to data portability\n- Right to object\n- Right to restrict processing\n- How to exercise these rights\n\n#### 7. Cookies & Tracking\n- Types of cookies used\n- Cookie purposes\n- How to control cookies\n- Third-party analytics\n\n#### 8. Children's Privacy\n- Age restrictions\n- Parental consent requirements\n\n#### 9. International Data Transfers\n- EU-US data transfers\n- Adequacy decisions\n- Safeguards in place\n\n#### 10. Changes to Privacy Policy\n- How users will be notified\n- Effective date\n- Version history\n\n#### 11. Contact & Complaints\n- How to contact us\n- Data protection officer (if applicable)\n- Right to lodge complaint with supervisory authority\n\n**Acceptance Criteria:**\n\n- [ ] Draft privacy policy with legal team/consultant\n- [ ] Ensure GDPR compliance\n- [ ] Ensure DSGVO compliance\n- [ ] Include Swiss data protection law requirements\n- [ ] Add clear, user-friendly language\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Design privacy policy page\n- [ ] Add link in footer and signup flow\n- [ ] Implement consent management\n- [ ] Add cookie banner with preferences\n- [ ] Set up data export functionality\n- [ ] Implement data deletion process\n- [ ] Create process for handling data requests\n- [ ] Set up versioning and change notifications\n- [ ] Legal review and approval\n- [ ] Publish and announce to users",
    "state": "CLOSED",
    "synced": true,
    "number": 235,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/235",
    "contentHash": "2ff37de561bde68f06a8ecc0c9b07a6f443a9fa56d5e1b3e2dbf2a50cbf2872a"
  },
  {
    "title": "[HIGH] Terms of Service",
    "labels": [
      "P1",
      "legal",
      "compliance",
      "documentation"
    ],
    "body": "Create comprehensive Terms of Service for the Helvetia Cloud platform to define the legal relationship with users and protect the business.\n\n**Current State:**\n- No terms of service\n- No legal agreement with users\n- Risk of liability and disputes\n\n**Requirements:**\n\n### Content to Include:\n\n#### 1. Introduction & Acceptance\n- Overview of services\n- Agreement to terms\n- Who can use the service\n- Changes to terms\n\n#### 2. Definitions\n- Service\n- User/Customer\n- Account\n- Content\n- Deployment\n\n#### 3. Account Registration\n- Account requirements\n- Account security\n- User responsibilities\n- Account termination\n\n#### 4. Service Description\n- Platform services offered\n- Service availability (SLA)\n- Service modifications\n- Beta features\n\n#### 5. Acceptable Use Policy\n- Permitted uses\n- Prohibited activities:\n  - Illegal content\n  - Malware/harmful code\n  - Resource abuse\n  - Cryptocurrency mining\n  - Spam/phishing\n  - DDoS attacks\n  - Copyright infringement\n- Enforcement and consequences\n\n#### 6. Content & Intellectual Property\n- User content ownership\n- License granted to Helvetia\n- Platform IP ownership\n- Copyright complaints (DMCA)\n- Trademark usage\n\n#### 7. Payment & Billing\n- Pricing and fees\n- Payment methods\n- Billing cycles\n- Refund policy\n- Late payment\n- Tax obligations\n\n#### 8. Service Limits & Quotas\n- Resource limits per plan\n- Fair use policy\n- Overage charges\n- Service throttling\n\n#### 9. Data & Privacy\n- Reference to Privacy Policy\n- Data ownership\n- Data backups\n- Data retention\n- Data portability\n\n#### 10. Security\n- Our security measures\n- User security responsibilities\n- Incident reporting\n- Vulnerability disclosure\n\n#### 11. Service Level Agreement (SLA)\n- Uptime guarantee\n- Maintenance windows\n- Service credits\n- Exclusions\n\n#### 12. Liability & Warranties\n- Service provided \"as is\"\n- Disclaimer of warranties\n- Limitation of liability\n- Indemnification\n- Force majeure\n\n#### 13. Termination\n- User termination rights\n- Our termination rights\n- Effects of termination\n- Data retention after termination\n- Survival of terms\n\n#### 14. Dispute Resolution\n- Governing law (Swiss law)\n- Jurisdiction\n- Arbitration clause (optional)\n- Class action waiver (where applicable)\n\n#### 15. Miscellaneous\n- Entire agreement\n- Severability\n- Waiver\n- Assignment\n- Third-party services\n- Contact information\n\n**Special Considerations:**\n\n- Swiss law compliance\n- EU law compliance (for EU users)\n- B2B vs B2C differences\n- Enterprise terms (if applicable)\n- Developer terms for API usage\n\n**Acceptance Criteria:**\n\n- [ ] Draft terms of service with legal team/consultant\n- [ ] Ensure compliance with Swiss law\n- [ ] Add EU-specific terms for EU users\n- [ ] Include acceptable use policy\n- [ ] Define clear SLA commitments\n- [ ] Add liability limitations\n- [ ] Include dispute resolution mechanism\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Design terms of service page\n- [ ] Add link in footer and signup flow\n- [ ] Require acceptance during signup\n- [ ] Implement terms version tracking\n- [ ] Set up notification for changes\n- [ ] Create separate enterprise terms (optional)\n- [ ] Legal review and approval\n- [ ] Publish and announce to users\n- [ ] Get existing user acceptance",
    "state": "CLOSED",
    "synced": true,
    "number": 236,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/236",
    "contentHash": "cba2017cb88b077cd7e4c7e2f622d891d5bf2ec84e905e30abc0da346d9af465"
  },
  {
    "title": "[MEDIUM] Frequently Asked Questions (FAQ)",
    "labels": [
      "P2",
      "documentation",
      "user-experience",
      "enhancement"
    ],
    "body": "Create a comprehensive FAQ page to answer common user questions and reduce support burden.\n\n**Current State:**\n- No FAQ page\n- Common questions answered repeatedly in support\n- No self-service help resource\n\n**FAQ Categories:**\n\n### General\n- What is Helvetia Cloud?\n- How does Helvetia Cloud work?\n- What can I deploy on Helvetia Cloud?\n- Where is my data hosted?\n- Is Helvetia Cloud secure?\n- How is Helvetia Cloud different from competitors?\n\n### Getting Started\n- How do I create an account?\n- How do I deploy my first application?\n- What programming languages are supported?\n- Do I need Docker knowledge?\n- Can I deploy existing Docker images?\n\n### Pricing & Billing\n- How much does Helvetia Cloud cost?\n- What's included in the free tier?\n- How is usage calculated?\n- When will I be charged?\n- Can I change my plan?\n- What payment methods are accepted?\n- How do I get a refund?\n- What happens if my payment fails?\n\n### Services & Deployments\n- How do I deploy a service?\n- What is a preview environment?\n- How do I set up auto-deployments?\n- How do I rollback a deployment?\n- Can I deploy databases?\n- How do I connect to my database?\n- What are the resource limits?\n- Can I scale my services?\n\n### Domains & SSL\n- How do I add a custom domain?\n- Is SSL/HTTPS automatic?\n- How long does domain setup take?\n- Can I use wildcard domains?\n- Do I need to purchase a domain?\n\n### Environment Variables\n- How do I set environment variables?\n- Are environment variables encrypted?\n- Can I use .env files?\n- How do I update environment variables?\n\n### Logs & Monitoring\n- How do I view logs?\n- How long are logs retained?\n- Can I export logs?\n- What metrics are available?\n- How do I set up alerts?\n\n### GitHub Integration\n- How does GitHub integration work?\n- Which repositories can I deploy?\n- Do I need webhook access?\n- Can I use private repositories?\n- Can I deploy from GitLab/Bitbucket?\n\n### Security & Compliance\n- Is my data secure?\n- How is data encrypted?\n- Are you GDPR compliant?\n- Where are backups stored?\n- Do you have a bug bounty program?\n- How do I report security issues?\n\n### Organizations & Teams\n- How do I create an organization?\n- How do I invite team members?\n- What are the different roles?\n- Can I transfer services between accounts?\n- How do I manage permissions?\n\n### Technical\n- What Docker versions are supported?\n- Can I use Docker Compose?\n- What ports can I expose?\n- How do I debug build failures?\n- Can I SSH into containers?\n- How do I run database migrations?\n- Can I use cron jobs?\n\n### Support & Help\n- How do I get help?\n- Do you offer phone support?\n- What's your response time?\n- Do you have a status page?\n- How do I report a bug?\n- Can I request features?\n\n### Account Management\n- How do I change my email?\n- How do I reset my password?\n- Can I delete my account?\n- What happens to my data after deletion?\n- How do I export my data?\n\n**Features:**\n\n- Search functionality\n- Category filtering\n- Related questions\n- \"Was this helpful?\" feedback\n- Link to support if not resolved\n- Multi-language support\n- Regular updates based on support tickets\n\n**Acceptance Criteria:**\n\n- [ ] Compile list of common questions from support tickets\n- [ ] Organize questions into logical categories\n- [ ] Write clear, concise answers\n- [ ] Add code examples where relevant\n- [ ] Include screenshots and diagrams\n- [ ] Create searchable FAQ page\n- [ ] Implement category filtering\n- [ ] Add related questions linking\n- [ ] Implement feedback mechanism\n- [ ] Create multi-language versions (EN, DE, FR, IT)\n- [ ] Make FAQ easily accessible from navigation\n- [ ] Set up analytics to track popular questions\n- [ ] Establish process for updating FAQ regularly\n- [ ] Link FAQ entries in support responses\n- [ ] Add FAQ schema markup for SEO",
    "state": "OPEN",
    "synced": true,
    "number": 237,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/237",
    "contentHash": "dd5dc0f1853cc25158dbce25a29c5ceeb020488ba872d8b30248b3fc7381ddcb"
  },
  {
    "title": "[MEDIUM] Platform Blog",
    "labels": [
      "P2",
      "marketing",
      "content",
      "enhancement"
    ],
    "body": "Create a blog for the Helvetia Cloud platform to share updates, tutorials, technical insights, and build community.\n\n**Current State:**\n- No blog or content marketing\n- Updates shared only through release notes\n- No technical content or thought leadership\n\n**Blog Purpose:**\n\n- Platform updates and announcements\n- Technical tutorials and how-tos\n- Industry insights and thought leadership\n- Customer success stories\n- Community highlights\n- SEO and inbound marketing\n\n**Content Categories:**\n\n### Announcements\n- New features and updates\n- Product roadmap\n- Platform milestones\n- Partnerships and integrations\n- Event participation\n\n### Tutorials\n- Deploy guides (Node.js, Python, Go, etc.)\n- Framework-specific tutorials (Next.js, Django, etc.)\n- Database setup guides\n- CI/CD integration\n- Performance optimization\n- Security best practices\n\n### Technical Deep Dives\n- Platform architecture\n- How we built X feature\n- Scaling strategies\n- Infrastructure decisions\n- Open source contributions\n\n### Use Cases\n- Customer success stories\n- Industry-specific solutions\n- Migration guides (from other platforms)\n- Cost comparison analyses\n\n### Company\n- Team updates\n- Company culture\n- Behind the scenes\n- Career opportunities\n\n**Technical Implementation:**\n\n### Technology Options:\n- **Next.js + MDX**: Full control, dynamic, SEO-friendly\n- **Ghost**: Powerful, dedicated blogging platform\n- **Strapi**: Headless CMS with flexibility\n- **WordPress**: Established, extensive plugins\n\n### Features Required:\n- Rich text editor\n- Code syntax highlighting\n- Image optimization\n- Categories and tags\n- Author profiles\n- Comments (optional)\n- Social sharing\n- RSS feed\n- Newsletter subscription\n- Search functionality\n- Related posts\n- Reading time estimates\n- Table of contents\n- Multi-language support\n\n### SEO Requirements:\n- Meta tags and descriptions\n- Open Graph images\n- Structured data (Article schema)\n- XML sitemap\n- Internal linking\n- Fast page loads\n- Mobile responsive\n\n**Content Strategy:**\n\n### Publishing Schedule:\n- 1-2 technical tutorials per month\n- 1 platform update per month\n- 1 thought leadership piece per quarter\n- Customer stories as available\n\n### Content Guidelines:\n- Clear, accessible writing\n- Code examples and demos\n- Visual aids (screenshots, diagrams)\n- Actionable takeaways\n- SEO optimization\n- Multi-language versions for key posts\n\n**Initial Content:**\n\n1. Welcome to Helvetia Cloud Blog\n2. Why We Built Helvetia Cloud\n3. Getting Started: Deploy Your First App\n4. Understanding Preview Environments\n5. Zero-Downtime Deployments Explained\n6. Database-as-a-Service Deep Dive\n7. Security Best Practices for Cloud Deployments\n8. Comparing Helvetia Cloud to Heroku/Railway/Render\n9. How to Migrate from Heroku to Helvetia Cloud\n10. Behind the Scenes: Our Infrastructure\n\n**Acceptance Criteria:**\n\n- [ ] Choose blogging platform/technology\n- [ ] Design blog layout matching platform branding\n- [ ] Set up blog infrastructure\n- [ ] Create content management workflow\n- [ ] Write and publish 5 initial blog posts\n- [ ] Implement SEO optimization\n- [ ] Add social sharing functionality\n- [ ] Set up newsletter integration\n- [ ] Create RSS feed\n- [ ] Add search functionality\n- [ ] Implement multi-language support\n- [ ] Set up analytics tracking\n- [ ] Create author profiles\n- [ ] Add related posts feature\n- [ ] Set up commenting system (optional)\n- [ ] Create content calendar\n- [ ] Establish editorial workflow\n- [ ] Promote blog in platform and marketing channels",
    "state": "OPEN",
    "synced": true,
    "number": 238,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/238",
    "contentHash": "51b538c05b44e6ab112c37b95635bc328b37e33d671ebbafdce0d8124ebd66b0"
  },
  {
    "title": "[LOW] Generate SDKs from OpenAPI Specification",
    "labels": [
      "P3",
      "enhancement",
      "developer-experience",
      "api",
      "future"
    ],
    "body": "Generate client SDKs for multiple programming languages from the OpenAPI specification to improve developer experience.\n\n**Current State:**\n- OpenAPI/Swagger documentation exists (or planned in #233)\n- Developers must manually construct API requests\n- No official SDKs for popular languages\n\n**Benefits:**\n\n- Easier integration for developers\n- Type-safe API clients\n- Reduced integration time\n- Better error handling\n- Consistent API usage patterns\n- Auto-completion in IDEs\n\n**Languages to Support:**\n\n1. **TypeScript/JavaScript**\n   - Full type definitions\n   - Works with Node.js and browsers\n   - npm package distribution\n\n2. **Python**\n   - Type hints support\n   - Async/sync methods\n   - PyPI package distribution\n\n3. **Go**\n   - Idiomatic Go code\n   - Context support\n   - Go modules distribution\n\n**SDK Generation Tools:**\n\n- **OpenAPI Generator**: Industry standard, supports 50+ languages\n- **Swagger Codegen**: Popular alternative\n- **oapi-codegen** (Go-specific): Better Go SDK generation\n- **openapi-typescript**: TypeScript-first SDK generation\n\n**SDK Features:**\n\n- Authentication handling (JWT tokens)\n- Request/response serialization\n- Error handling and custom exceptions\n- Retry logic and timeouts\n- Rate limit handling\n- Pagination support\n- Type safety\n- Documentation and examples\n- Unit tests\n\n**SDK Structure Example (TypeScript):**\n\n```typescript\nimport { HelvetiaClient } from '@helvetia/sdk';\n\nconst client = new HelvetiaClient({\n  apiKey: 'your-api-key',\n  baseUrl: 'https://api.helvetia.cloud',\n});\n\n// Type-safe API calls\nconst services = await client.services.list();\nconst service = await client.services.create({\n  name: 'my-app',\n  repoUrl: 'https://github.com/user/repo',\n  branch: 'main',\n});\n\nawait client.services.deploy(service.id);\nconst logs = await client.deployments.logs(deployment.id);\n```\n\n**SDK Structure Example (Python):**\n\n```python\nfrom helvetia import HelvetiaClient\n\nclient = HelvetiaClient(\n    api_key=\"your-api-key\",\n    base_url=\"https://api.helvetia.cloud\"\n)\n\n# Type-hinted API calls\nservices = client.services.list()\nservice = client.services.create(\n    name=\"my-app\",\n    repo_url=\"https://github.com/user/repo\",\n    branch=\"main\"\n)\n\nclient.services.deploy(service.id)\nlogs = client.deployments.logs(deployment.id)\n```\n\n**SDK Structure Example (Go):**\n\n```go\nimport \"github.com/helvetia/go-sdk\"\n\nclient := helvetia.NewClient(\"your-api-key\")\n\nservices, err := client.Services.List(ctx)\nservice, err := client.Services.Create(ctx, &helvetia.ServiceCreateRequest{\n    Name:    \"my-app\",\n    RepoURL: \"https://github.com/user/repo\",\n    Branch:  \"main\",\n})\n\nerr = client.Services.Deploy(ctx, service.ID)\nlogs, err := client.Deployments.Logs(ctx, deployment.ID)\n```\n\n**Distribution:**\n\n- TypeScript: npm (@helvetia/sdk)\n- Python: PyPI (helvetia-sdk)\n- Go: GitHub module (github.com/helvetia/go-sdk)\n\n**Documentation:**\n\n- SDK installation guide\n- Quick start examples\n- API reference\n- Advanced usage patterns\n- Error handling guide\n- Changelog\n\n**CI/CD Integration:**\n\n- Automated SDK generation on OpenAPI spec changes\n- Automated testing\n- Automated versioning and releases\n- Automated documentation publishing\n\n**Acceptance Criteria:**\n\n- [ ] Ensure OpenAPI specification is complete and accurate\n- [ ] Choose SDK generation tools for each language\n- [ ] Configure SDK generators with custom templates\n- [ ] Generate TypeScript/JavaScript SDK\n- [ ] Generate Python SDK\n- [ ] Generate Go SDK\n- [ ] Add authentication handling\n- [ ] Implement error handling\n- [ ] Add retry logic and rate limiting\n- [ ] Create comprehensive examples\n- [ ] Write SDK documentation\n- [ ] Add unit tests for SDKs\n- [ ] Set up CI/CD for automated generation\n- [ ] Publish to package managers (npm, PyPI, Go modules)\n- [ ] Create SDK migration guides\n- [ ] Announce SDKs to community",
    "state": "OPEN",
    "synced": true,
    "number": 246,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/246",
    "contentHash": "dab6dc49b7d594e7a15d976de20298e7f65816301e8bd8784a2ab1627752bbcf"
  },
  {
    "title": "[LOW] Export Postman Collection from API",
    "labels": [
      "P3",
      "enhancement",
      "developer-experience",
      "api",
      "future"
    ],
    "body": "Generate and export a Postman collection from the API to enable easy API exploration and testing.\n\n**Current State:**\n- API endpoints exist but no Postman collection\n- Developers must manually create requests in Postman\n- No standardized way to test API\n\n**Benefits:**\n\n- Quick API exploration without reading documentation\n- Pre-configured requests with examples\n- Easy testing and debugging\n- Team collaboration on API development\n- Onboarding new developers faster\n- API versioning support\n\n**Postman Collection Features:**\n\n### Organization\n- Folder structure matching API categories:\n  - Authentication\n  - Services\n  - Deployments\n  - Databases\n  - Organizations\n  - Feature Flags\n  - GitHub Integration\n  - Webhooks\n\n### Request Configuration\n- Pre-filled endpoints and methods\n- Request headers (Content-Type, Authorization)\n- Example request bodies\n- Path parameters\n- Query parameters\n- Environment variables\n\n### Authentication\n- JWT token management\n- OAuth2 flow (GitHub)\n- Automatic token refresh\n- Environment variable for API key\n\n### Examples\n- Multiple request/response examples per endpoint\n- Success scenarios\n- Error scenarios\n- Edge cases\n\n### Documentation\n- Request descriptions\n- Parameter descriptions\n- Response schema documentation\n- Code snippets\n\n**Environment Variables:**\n\n```json\n{\n  \"api_base_url\": \"https://api.helvetia.cloud\",\n  \"api_key\": \"\",\n  \"access_token\": \"\",\n  \"service_id\": \"\",\n  \"deployment_id\": \"\",\n  \"organization_id\": \"\"\n}\n```\n\n**Generation Options:**\n\n1. **From OpenAPI Spec**: Use OpenAPI-to-Postman converter\n   - Automatic generation\n   - Stays in sync with API\n   - Requires OpenAPI spec (#233)\n\n2. **Manual Creation**: Create and maintain manually\n   - More control\n   - Better documentation\n   - Requires manual updates\n\n3. **Postman API**: Generate programmatically via Postman API\n   - Automated updates\n   - Version control\n   - CI/CD integration\n\n**Implementation Steps:**\n\n### Option 1: OpenAPI to Postman\n```bash\n# Install converter\nnpm install -g openapi-to-postmanv2\n\n# Generate collection\nopenapi2postmanv2 -s openapi.yaml -o helvetia-cloud.postman.json\n```\n\n### Option 2: Manual Creation\n- Create collection in Postman\n- Add folders for each API category\n- Create requests with examples\n- Export as JSON\n- Version control in repository\n\n**Collection Structure:**\n\n```\nHelvetia Cloud API\n Authentication\n    GitHub OAuth Login\n    Verify Token\n    Logout\n Services\n    List Services\n    Create Service\n    Get Service\n    Update Service\n    Delete Service\n    Deploy Service\n    Restart Service\n Deployments\n    List Deployments\n    Get Deployment\n    Get Deployment Logs\n    Stream Logs (SSE)\n Databases\n    List Databases\n    Create Database\n    Get Database\n    Delete Database\n Organizations\n    List Organizations\n    Create Organization\n    Get Organization\n    Manage Members\n GitHub Integration\n    List Organizations\n    List Repositories\n    List Branches\n Webhooks\n     GitHub Webhook Handler\n```\n\n**Distribution:**\n\n- Publish to Postman public workspace\n- Download link on website\n- GitHub repository with collection JSON\n- Documentation with import instructions\n- Versioned releases\n\n**Testing Pre-request Scripts:**\n\n```javascript\n// Auto-refresh token if expired\nif (pm.environment.get('token_expires_at') < Date.now()) {\n  // Refresh token logic\n}\n\n// Set authorization header\npm.request.headers.add({\n  key: 'Authorization',\n  value: `Bearer ${pm.environment.get('access_token')}`\n});\n```\n\n**Testing Post-response Scripts:**\n\n```javascript\n// Save tokens from login response\nif (pm.response.code === 200) {\n  const response = pm.response.json();\n  pm.environment.set('access_token', response.token);\n  pm.environment.set('token_expires_at', Date.now() + 3600000);\n}\n\n// Basic response validation\npm.test('Status code is 200', () => {\n  pm.response.to.have.status(200);\n});\n\npm.test('Response has expected structure', () => {\n  pm.expect(pm.response.json()).to.have.property('id');\n});\n```\n\n**Acceptance Criteria:**\n\n- [ ] Decide on generation method (OpenAPI vs manual)\n- [ ] Create collection structure\n- [ ] Add all API endpoints\n- [ ] Configure authentication flows\n- [ ] Add request/response examples\n- [ ] Set up environment variables\n- [ ] Add pre-request scripts\n- [ ] Add test scripts\n- [ ] Write collection documentation\n- [ ] Publish to Postman workspace\n- [ ] Add download link to website\n- [ ] Version control collection JSON in repo\n- [ ] Set up automated updates (if using OpenAPI)\n- [ ] Create import guide\n- [ ] Announce availability to users",
    "state": "OPEN",
    "synced": true,
    "number": 247,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/247",
    "contentHash": "34f0b7c0049ca49052359c52919d5547fa4dbe336ee51bba7b7b229d38ff41a4"
  },
  {
    "title": "[MEDIUM] Add GraphQL API (v2.0)",
    "labels": [
      "P2",
      "enhancement",
      "api",
      "feature",
      "future"
    ],
    "body": "Implement a GraphQL API alongside the existing REST API to provide a more flexible and efficient querying interface.\n\n**Current State:**\n- REST API only\n- Multiple requests needed for related data\n- Over-fetching and under-fetching issues\n- No type introspection\n\n**Benefits of GraphQL:**\n\n- Fetch exactly the data you need\n- Single request for complex queries\n- Strong typing and introspection\n- Real-time subscriptions\n- Better developer experience\n- Reduced bandwidth usage\n- Automatic documentation\n\n**Implementation Approach:**\n\n### Technology Stack\n- **Apollo Server** with Fastify integration\n- **GraphQL.js** for schema definition\n- **DataLoader** for batching and caching\n- **graphql-scalars** for custom scalar types\n\n### Schema Design\n\n```graphql\ntype Query {\n  # User & Auth\n  me: User!\n  \n  # Services\n  services(organizationId: ID): [Service!]!\n  service(id: ID!): Service\n  \n  # Deployments\n  deployments(serviceId: ID!, first: Int, after: String): DeploymentConnection!\n  deployment(id: ID!): Deployment\n  \n  # Organizations\n  organizations: [Organization!]!\n  organization(id: ID!): Organization\n  \n  # Databases\n  databases(organizationId: ID): [Database!]!\n  database(id: ID!): Database\n  \n  # Feature Flags\n  featureFlags: [FeatureFlag!]!\n  featureFlag(key: String!): FeatureFlag\n}\n\ntype Mutation {\n  # Services\n  createService(input: CreateServiceInput!): Service!\n  updateService(id: ID!, input: UpdateServiceInput!): Service!\n  deleteService(id: ID!): Boolean!\n  deployService(id: ID!): Deployment!\n  restartService(id: ID!): Boolean!\n  \n  # Deployments\n  cancelDeployment(id: ID!): Deployment!\n  \n  # Organizations\n  createOrganization(input: CreateOrganizationInput!): Organization!\n  updateOrganization(id: ID!, input: UpdateOrganizationInput!): Organization!\n  addMember(organizationId: ID!, userId: ID!, role: Role!): OrganizationMember!\n  removeMember(organizationId: ID!, userId: ID!): Boolean!\n  \n  # Feature Flags\n  toggleFeatureFlag(key: String!, enabled: Boolean!): FeatureFlag!\n}\n\ntype Subscription {\n  # Real-time updates\n  deploymentStatusChanged(deploymentId: ID!): Deployment!\n  serviceMetricsUpdated(serviceId: ID!): ServiceMetrics!\n  deploymentLogsAdded(deploymentId: ID!): LogEntry!\n}\n\ntype User {\n  id: ID!\n  username: String!\n  email: String!\n  avatarUrl: String\n  organizations: [Organization!]!\n  services: [Service!]!\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n\ntype Service {\n  id: ID!\n  name: String!\n  type: ServiceType!\n  status: ServiceStatus!\n  repoUrl: String\n  branch: String\n  customDomain: String\n  port: Int\n  envVars: [EnvVar!]!\n  organization: Organization!\n  deployments(first: Int, after: String): DeploymentConnection!\n  latestDeployment: Deployment\n  metrics: ServiceMetrics\n  health: HealthStatus\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n\ntype Deployment {\n  id: ID!\n  service: Service!\n  status: DeploymentStatus!\n  commitHash: String\n  commitMessage: String\n  imageTag: String\n  logs(first: Int, after: String): LogConnection!\n  startedAt: DateTime\n  completedAt: DateTime\n  createdAt: DateTime!\n}\n\ntype Organization {\n  id: ID!\n  name: String!\n  slug: String!\n  members: [OrganizationMember!]!\n  services: [Service!]!\n  createdAt: DateTime!\n  updatedAt: DateTime!\n}\n\nenum ServiceType {\n  DOCKER\n  STATIC\n  POSTGRES\n  MYSQL\n  REDIS\n  COMPOSE\n}\n\nenum ServiceStatus {\n  IDLE\n  DEPLOYING\n  RUNNING\n  STOPPED\n  FAILED\n}\n\nenum Role {\n  OWNER\n  ADMIN\n  DEVELOPER\n  VIEWER\n}\n\n# Pagination\ntype DeploymentConnection {\n  edges: [DeploymentEdge!]!\n  pageInfo: PageInfo!\n  totalCount: Int!\n}\n\ntype DeploymentEdge {\n  node: Deployment!\n  cursor: String!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\n# Custom scalars\nscalar DateTime\nscalar JSON\n```\n\n**Example Queries:**\n\n### Fetch Service with Deployments\n```graphql\nquery GetServiceDetails($id: ID!) {\n  service(id: $id) {\n    id\n    name\n    status\n    customDomain\n    latestDeployment {\n      id\n      status\n      commitHash\n      commitMessage\n      completedAt\n    }\n    deployments(first: 10) {\n      edges {\n        node {\n          id\n          status\n          createdAt\n        }\n      }\n      pageInfo {\n        hasNextPage\n      }\n    }\n    metrics {\n      cpu\n      memory\n      status\n    }\n  }\n}\n```\n\n### Create and Deploy Service\n```graphql\nmutation CreateAndDeploy($input: CreateServiceInput!) {\n  createService(input: $input) {\n    id\n    name\n    status\n  }\n}\n\nmutation DeployService($id: ID!) {\n  deployService(id: $id) {\n    id\n    status\n    startedAt\n  }\n}\n```\n\n### Subscribe to Deployment Logs\n```graphql\nsubscription WatchDeploymentLogs($deploymentId: ID!) {\n  deploymentLogsAdded(deploymentId: $deploymentId) {\n    timestamp\n    message\n    level\n  }\n}\n```\n\n**Implementation Strategy:**\n\n### Phase 1: Foundation\n- Set up Apollo Server with Fastify\n- Define GraphQL schema\n- Implement basic resolvers\n- Add authentication/authorization\n- Set up DataLoader for batching\n\n### Phase 2: Core Features\n- Implement all Query resolvers\n- Implement all Mutation resolvers\n- Add pagination support\n- Implement error handling\n- Add request validation\n\n### Phase 3: Real-time Features\n- Set up subscriptions with Redis PubSub\n- Implement deployment status subscriptions\n- Implement metrics subscriptions\n- Implement log streaming subscriptions\n\n### Phase 4: Developer Experience\n- Set up GraphQL Playground\n- Add introspection\n- Generate TypeScript types\n- Create documentation\n- Add examples and tutorials\n\n**Technical Considerations:**\n\n- **N+1 Problem**: Use DataLoader for batching\n- **Authentication**: JWT tokens same as REST API\n- **Authorization**: Field-level permissions\n- **Rate Limiting**: Per-query complexity analysis\n- **Caching**: Redis caching for frequent queries\n- **Error Handling**: Structured error responses\n- **Versioning**: Deprecation strategy for fields\n\n**Coexistence with REST API:**\n\n- GraphQL at `/graphql` endpoint\n- REST API remains at existing endpoints\n- Both APIs share business logic layer\n- Gradual migration strategy\n- No breaking changes to REST API\n\n**Performance Optimizations:**\n\n- Query complexity analysis\n- Query depth limiting\n- DataLoader for batching\n- Redis caching\n- Persistent queries\n- Query whitelisting (production)\n\n**Acceptance Criteria:**\n\n- [ ] Set up Apollo Server with Fastify integration\n- [ ] Define complete GraphQL schema\n- [ ] Implement authentication and authorization\n- [ ] Implement Query resolvers\n- [ ] Implement Mutation resolvers\n- [ ] Implement Subscription resolvers\n- [ ] Add DataLoader for N+1 prevention\n- [ ] Implement pagination\n- [ ] Add error handling\n- [ ] Set up GraphQL Playground\n- [ ] Configure rate limiting\n- [ ] Add Redis caching\n- [ ] Generate TypeScript types\n- [ ] Write API documentation\n- [ ] Create example queries\n- [ ] Add comprehensive tests\n- [ ] Monitor performance\n- [ ] Announce GraphQL API availability",
    "state": "OPEN",
    "synced": true,
    "number": 248,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/248",
    "contentHash": "8d68f6441c6557053d0eef3bf08b2e5f71975e9346cd57aae031bbabdd4c2e22"
  },
  {
    "title": "[LOW] Interactive Rate Limit Calculator",
    "labels": [
      "P3",
      "enhancement",
      "developer-experience",
      "documentation",
      "future"
    ],
    "body": "Create an interactive calculator to help developers understand and plan for API rate limits.\n\n**Current State:**\n- Rate limiting is implemented (or planned in #58)\n- Rate limit documentation exists\n- No interactive tool to estimate rate limit needs\n\n**Problem:**\n\n- Developers unsure if rate limits will be sufficient\n- Hard to estimate API usage before implementation\n- Difficult to understand rate limit math\n- No guidance on optimization strategies\n\n**Solution:**\n\nBuild an interactive web-based calculator that:\n- Shows current rate limit tiers\n- Calculates estimated API calls\n- Suggests appropriate tier\n- Provides optimization tips\n- Visualizes rate limit consumption\n\n**Calculator Features:**\n\n### Input Fields\n\n1. **Deployment Frequency**\n   - Number of services\n   - Deployments per service per day\n   - CI/CD integration (yes/no)\n\n2. **Monitoring & Logs**\n   - Services monitored\n   - Log fetch frequency\n   - Metrics polling interval\n\n3. **Dashboard Usage**\n   - Active users\n   - Page views per user per day\n   - Real-time features enabled\n\n4. **Webhook Events**\n   - GitHub events per day\n   - Other webhook sources\n\n5. **API Integration**\n   - External integrations\n   - CLI tool usage\n   - Custom automation\n\n### Calculation Logic\n\n```typescript\ninterface UsageEstimate {\n  deployments: number;      // Deploy + status checks\n  monitoring: number;       // Metrics + health checks\n  logs: number;            // Log fetching\n  dashboard: number;       // Web UI requests\n  webhooks: number;        // Webhook processing\n  apiIntegration: number;  // CLI + custom scripts\n}\n\nfunction calculateDailyRequests(inputs: UserInputs): UsageEstimate {\n  const estimate = {\n    deployments: \n      inputs.numServices * \n      inputs.deploymentsPerDay * \n      10, // ~10 API calls per deployment\n    \n    monitoring: \n      inputs.numServices * \n      (24 * 60 / inputs.metricsIntervalMinutes) * \n      2, // metrics + health check\n    \n    logs: \n      inputs.numServices * \n      inputs.logFetchesPerDay * \n      3, // fetch + pagination\n    \n    dashboard: \n      inputs.activeUsers * \n      inputs.pageViewsPerUser * \n      5, // ~5 API calls per page\n    \n    webhooks: \n      inputs.githubEventsPerDay * \n      2, // webhook + status update\n    \n    apiIntegration: \n      inputs.cliCommandsPerDay * \n      3, // avg 3 API calls per command\n  };\n  \n  return estimate;\n}\n\nfunction calculateTotalRequests(estimate: UsageEstimate): number {\n  return Object.values(estimate).reduce((a, b) => a + b, 0);\n}\n```\n\n### Output Display\n\n1. **Estimated API Calls**\n   - Daily total\n   - Per hour average\n   - Per minute average\n   - Breakdown by category (pie chart)\n\n2. **Rate Limit Comparison**\n   - Current tier: \"100 requests/minute\"\n   - Your estimate: \"45 requests/minute\"\n   - Headroom: \"55% buffer\"\n   - Status: \" Within limits\" or \" Upgrade needed\"\n\n3. **Tier Recommendations**\n   - Recommended tier\n   - Cost comparison\n   - Next tier up (for growth)\n\n4. **Optimization Tips**\n   - Cache responses where possible\n   - Batch API requests\n   - Use webhooks instead of polling\n   - Implement request queuing\n   - Use GraphQL for complex queries\n\n### Visualization\n\n- **Breakdown Pie Chart**: Show distribution of API calls\n- **Timeline Chart**: Show hourly distribution\n- **Tier Comparison**: Visual comparison of tiers\n- **Usage Gauge**: Current vs limit visualization\n\n**UI Design:**\n\n```\n\n   API Rate Limit Calculator                       \n\n                                                      \n   Your Usage Profile                              \n         \n   Services: [  5  ]                               \n   Deployments/day per service: [ 3 ]              \n   Active users: [ 10 ]                            \n   Metrics interval: [ 5 ] minutes                 \n         \n                                                      \n   Estimated API Usage                             \n         \n   Total: 2,450 requests/day                       \n   Average: 102 requests/hour                      \n   Peak: ~1.7 requests/minute                      \n                                                   \n   Breakdown:                                      \n                 \n    Deployments:    15% (367 req)               \n    Monitoring:     40% (980 req)               \n    Logs:          10% (245 req)               \n    Dashboard:     30% (735 req)               \n    Webhooks:       5% (123 req)               \n         \n                                                      \n   Recommended Tier: Starter                       \n         \n   Your usage: 1.7 req/min                         \n   Tier limit: 100 req/min                         \n   Headroom: 98%                                   \n                                                   \n   [] 2%              \n         \n                                                      \n   Optimization Tips                               \n   Enable caching to reduce monitoring calls         \n   Use webhooks for deployment status                \n   Batch log fetches when possible                   \n                                                      \n  [Calculate Again]  [Export Report]                  \n\n```\n\n**Technical Implementation:**\n\n### Frontend\n- React component with form inputs\n- Real-time calculation updates\n- Chart.js or Recharts for visualizations\n- Responsive design\n\n### Features\n- Save/load usage profiles\n- Export as PDF report\n- Share calculation link\n- Compare multiple scenarios\n\n**Integration Points:**\n\n- Link from API documentation\n- Embed in pricing page\n- Link from rate limit error messages\n- Include in onboarding flow\n\n**Acceptance Criteria:**\n\n- [ ] Design calculator UI/UX\n- [ ] Define rate limit tiers and formulas\n- [ ] Implement input form\n- [ ] Build calculation logic\n- [ ] Add real-time calculation updates\n- [ ] Create breakdown visualizations\n- [ ] Add tier comparison display\n- [ ] Implement optimization suggestions\n- [ ] Add save/load profiles feature\n- [ ] Implement PDF export\n- [ ] Add share link functionality\n- [ ] Make mobile responsive\n- [ ] Add calculator to documentation\n- [ ] Link from pricing page\n- [ ] Add analytics tracking\n- [ ] Create usage examples/presets\n- [ ] Test with various scenarios",
    "state": "OPEN",
    "synced": true,
    "number": 249,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/249",
    "contentHash": "ec6d1a57a2895445c17b9caf82414cc8e38ee0fe4f8f61c8295727219458d244"
  },
  {
    "title": "[MEDIUM] Automated Usage Collection from Running Containers",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "billing",
      "backend"
    ],
    "body": "Implement automated collection of resource usage metrics from running containers for billing purposes.\n\n**Current State:**\n- Usage tracking infrastructure exists (UsageTrackingService)\n- Manual usage recording API is available\n- No automated collection from containers\n- No background job for metrics collection\n\n**Scope:**\n\nThis issue covers Phase 3 of the Stripe Billing Integration (see #230).\n\n**Acceptance Criteria:**\n\n- [ ] Create background worker job for usage collection\n- [ ] Implement compute hours tracking\n- [ ] Implement memory GB-hours tracking  \n- [ ] Implement bandwidth GB tracking\n- [ ] Implement storage GB tracking\n- [ ] Schedule periodic collection (every 5-15 min)\n- [ ] Add usage aggregation logic\n- [ ] Create historical usage endpoints\n- [ ] Integrate with Stripe metered billing\n- [ ] Add error handling and retry logic\n- [ ] Implement data rollup and archival\n- [ ] Add monitoring and alerting\n- [ ] Write unit tests for metrics calculation\n- [ ] Write integration tests for collection job\n- [ ] Document usage collection system\n- [ ] Add configuration for collection intervals",
    "state": "CLOSED",
    "synced": true,
    "number": 256,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/256",
    "contentHash": "839a43913fa70f07952e86503b741b43d6383a07c7776067579ba3c91441c663"
  },
  {
    "title": "[HIGH] Resource Limit Enforcement Middleware",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "billing",
      "security",
      "backend"
    ],
    "body": "Implement middleware to enforce subscription-based resource limits and prevent abuse.\n\n**Current State:**\n- Subscription tiers defined with resource limits\n- SubscriptionService provides getResourceLimits() method\n- No enforcement of these limits\n- Users can exceed their tier quotas\n\n**Scope:**\n\nThis issue covers Phase 4 of the Stripe Billing Integration (see #230).\n\n**Acceptance Criteria:**\n\n- [ ] Create subscription status middleware\n- [ ] Implement service count enforcement\n- [ ] Implement memory limit enforcement\n- [ ] Implement CPU limit enforcement\n- [ ] Implement bandwidth limit enforcement\n- [ ] Implement storage limit enforcement\n- [ ] Add grace period handling (7 days)\n- [ ] Implement automatic service suspension\n- [ ] Add payment retry logic\n- [ ] Create background job for suspension\n- [ ] Add email notifications for suspensions\n- [ ] Update frontend to show limits and usage\n- [ ] Add upgrade prompts when limits reached\n- [ ] Write unit tests for middleware\n- [ ] Write integration tests for enforcement\n- [ ] Document enforcement policies\n- [ ] Add monitoring for enforcement events",
    "state": "CLOSED",
    "synced": true,
    "number": 257,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/257",
    "contentHash": "8b70a8e6bc787e9d8c0923ad9624a21ba21ffdb62669f5bb81f2801b29f35bde"
  },
  {
    "title": "[HIGH] Frontend Billing Dashboard UI",
    "labels": [
      "P1",
      "enhancement",
      "feature",
      "billing",
      "frontend",
      "ui/ux"
    ],
    "body": "Create a comprehensive billing dashboard UI for subscription management, usage monitoring, and payment handling.\n\n**Current State:**\n- Billing backend APIs are implemented\n- No frontend UI for billing features\n- Users cannot manage subscriptions or view usage\n\n**Scope:**\n\nThis issue covers Phase 5 of the Stripe Billing Integration (see #230).\n\n**Acceptance Criteria:**\n\n- [ ] Create billing overview page\n- [ ] Implement current plan card\n- [ ] Build usage metrics display\n- [ ] Create plan selector component\n- [ ] Implement payment method card\n- [ ] Build invoice list component\n- [ ] Add invoice download functionality\n- [ ] Implement upgrade flow\n- [ ] Implement downgrade flow\n- [ ] Add confirmation dialogs\n- [ ] Create success/cancel pages\n- [ ] Integrate with Stripe Checkout\n- [ ] Integrate with Stripe Customer Portal\n- [ ] Add loading states\n- [ ] Add error handling\n- [ ] Ensure mobile responsiveness\n- [ ] Add dark/light mode support\n- [ ] Test accessibility\n- [ ] Add usage forecasting (optional)\n- [ ] Write component tests\n- [ ] Update navigation to include billing link\n- [ ] Add billing notifications/alerts",
    "state": "CLOSED",
    "synced": true,
    "number": 258,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/258",
    "contentHash": "b8eca15ad0443940426cb6fc4bc8def03f8bd0f4b02958871615641a313ba80a"
  },
  {
    "title": "[MEDIUM] Comprehensive Billing Tests",
    "labels": [
      "P2",
      "testing",
      "quality",
      "billing",
      "backend"
    ],
    "body": "Add comprehensive test coverage for billing services, controllers, and webhook handlers.\n\n**Current State:**\n- Billing implementation is complete\n- No tests for billing features\n- Risk of bugs in payment processing\n\n**Scope:**\n\nThis issue covers Phase 6 (Testing) of the Stripe Billing Integration (see #230).\n\n**Acceptance Criteria:**\n\n- [ ] Write unit tests for BillingService (>80% coverage)\n- [ ] Write unit tests for SubscriptionService (>80% coverage)\n- [ ] Write unit tests for UsageTrackingService (>80% coverage)\n- [ ] Write integration tests for BillingController\n- [ ] Write integration tests for StripeWebhookController\n- [ ] Write tests for subscription middleware\n- [ ] Write tests for resource enforcement\n- [ ] Create mock Stripe client\n- [ ] Create test fixtures\n- [ ] Test webhook signature verification\n- [ ] Test all Stripe event types\n- [ ] Test error handling\n- [ ] Test edge cases (grace period, limits, etc.)\n- [ ] Add E2E tests for checkout flow (optional)\n- [ ] Achieve minimum 80% code coverage\n- [ ] Set up test database for integration tests\n- [ ] Document test setup and execution",
    "state": "CLOSED",
    "synced": true,
    "number": 259,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/259",
    "contentHash": "2a920f457382d05e6caa82c432d4d7c6b049a944230ffcb563ba5d42d39dda11"
  },
  {
    "title": "[MEDIUM] Email/Password Authentication & GitHub Linking",
    "labels": [
      "P2",
      "enhancement",
      "feature",
      "auth",
      "security"
    ],
    "body": "Currently, only GitHub OAuth is supported. Users should be able to sign up and sign in using **email and password**, with the capability to link their GitHub account later for deployments.\n\n**Requirements:**\n- **Email Signup/Login**: Standard email/password flow.\n- **Deferred Linking**: Allow connecting a GitHub account from the dashboard settings after signup.\n- **Account Merging**: Handle scenarios where a user signs up with an email that matches an existing GitHub user (or vice-versa), or strictly separate them until linked.\n\n**Acceptance Criteria:**\n- [ ] Update `User` model for password support (ensure secure hashing per #183).\n- [ ] Implement `/auth/register` and `/auth/login` endpoints.\n- [ ] Create Email/Password UI forms on the login page.\n- [ ] Add \"Connect GitHub\" section in user settings.\n- [ ] Allow triggering deployments only if GitHub is connected (or handle non-GitHub deployments).\n- [ ] Add integration tests for the new auth flow.",
    "state": "OPEN",
    "synced": true,
    "number": 294,
    "url": "https://github.com/ramiz4/helvetia-cloud/issues/294",
    "contentHash": "cd532d14e04d85d7b6d1e00551707780ded34e7def6f4d90118abdaeb69314e3"
  }
]